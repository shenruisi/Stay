(()=>{var __webpack_modules__={"./src/darkmode/dark.user.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('__webpack_require__(/*! core-js/modules/es.array.push.js */ "./node_modules/core-js/modules/es.array.push.js");\n__webpack_require__(/*! core-js/modules/web.dom-exception.stack.js */ "./node_modules/core-js/modules/web.dom-exception.stack.js");\n/* eslint-disable */\n(function () {\n  "use strict";\n\n  // console.log("darkUser---startTime-1=", new Date().getTime());\n  /*! *****************************************************************************\n  Dark Reader v4.9.42  https://darkreader.org/\n  Copyright (c) Microsoft Corporation.\n   Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** */\n  const userAgent = typeof navigator === "undefined" ? "some useragent" : navigator.userAgent.toLowerCase();\n  const platform = typeof navigator === "undefined" ? "some platform" : navigator.platform.toLowerCase();\n  const isChromium = userAgent.includes("chrome") || userAgent.includes("chromium");\n  const isThunderbird = userAgent.includes("thunderbird");\n  const isSafari = userAgent.includes("safari") || isThunderbird;\n  userAgent.includes("vivaldi");\n  userAgent.includes("yabrowser");\n  userAgent.includes("opr") || userAgent.includes("opera");\n  userAgent.includes("edg");\n  // const isSafari = userAgent.includes("safari") && !isChromium;\n  platform.startsWith("win");\n  platform.startsWith("mac");\n  userAgent.includes("mobile");\n  var isWindows = platform.startsWith(\'win\');\n  var isMacOS = platform.startsWith(\'mac\');\n  var ThemeEngines = {\n    cssFilter: \'cssFilter\',\n    svgFilter: \'svgFilter\',\n    staticTheme: \'staticTheme\',\n    dynamicTheme: \'dynamicTheme\'\n  };\n  var DEFAULT_COLORS = {\n    darkScheme: {\n      background: \'#181a1b\',\n      text: \'#e8e6e3\'\n    },\n    lightScheme: {\n      background: \'#dcdad7\',\n      text: \'#181a1b\'\n    }\n  };\n  var DEFAULT_THEME = {\n    mode: 1,\n    brightness: 100,\n    contrast: 100,\n    grayscale: 0,\n    sepia: 0,\n    useFont: false,\n    fontFamily: isMacOS ? \'Helvetica Neue\' : isWindows ? \'Segoe UI\' : \'Open Sans\',\n    textStroke: 0,\n    engine: ThemeEngines.dynamicTheme,\n    stylesheet: \'\',\n    darkSchemeBackgroundColor: DEFAULT_COLORS.darkScheme.background,\n    darkSchemeTextColor: DEFAULT_COLORS.darkScheme.text,\n    lightSchemeBackgroundColor: DEFAULT_COLORS.lightScheme.background,\n    lightSchemeTextColor: DEFAULT_COLORS.lightScheme.text,\n    scrollbarColor: isMacOS ? \'\' : \'auto\',\n    selectionColor: \'auto\',\n    styleSystemControls: true,\n    lightColorScheme: \'Default\',\n    darkColorScheme: \'Default\',\n    immediateModify: false\n  };\n  const MessageType = {\n    UI_GET_DATA: "ui-get-data",\n    UI_GET_ACTIVE_TAB_INFO: "ui-get-active-tab-info",\n    UI_SUBSCRIBE_TO_CHANGES: "ui-subscribe-to-changes",\n    UI_UNSUBSCRIBE_FROM_CHANGES: "ui-unsubscribe-from-changes",\n    UI_CHANGE_SETTINGS: "ui-change-settings",\n    UI_SET_THEME: "ui-set-theme",\n    UI_SET_SHORTCUT: "ui-set-shortcut",\n    UI_TOGGLE_URL: "ui-toggle-url",\n    UI_MARK_NEWS_AS_READ: "ui-mark-news-as-read",\n    UI_LOAD_CONFIG: "ui-load-config",\n    UI_APPLY_DEV_DYNAMIC_THEME_FIXES: "ui-apply-dev-dynamic-theme-fixes",\n    UI_RESET_DEV_DYNAMIC_THEME_FIXES: "ui-reset-dev-dynamic-theme-fixes",\n    UI_APPLY_DEV_INVERSION_FIXES: "ui-apply-dev-inversion-fixes",\n    UI_RESET_DEV_INVERSION_FIXES: "ui-reset-dev-inversion-fixes",\n    UI_APPLY_DEV_STATIC_THEMES: "ui-apply-dev-static-themes",\n    UI_RESET_DEV_STATIC_THEMES: "ui-reset-dev-static-themes",\n    UI_SAVE_FILE: "ui-save-file",\n    UI_REQUEST_EXPORT_CSS: "ui-request-export-css",\n    BG_CHANGES: "bg-changes",\n    BG_ADD_CSS_FILTER: "bg-add-css-filter",\n    BG_ADD_STATIC_THEME: "bg-add-static-theme",\n    BG_ADD_SVG_FILTER: "bg-add-svg-filter",\n    BG_ADD_DYNAMIC_THEME: "bg-add-dynamic-theme",\n    BG_EXPORT_CSS: "bg-export-css",\n    BG_UNSUPPORTED_SENDER: "bg-unsupported-sender",\n    BG_CLEAN_UP: "bg-clean-up",\n    BG_RELOAD: "bg-reload",\n    BG_FETCH_RESPONSE: "bg-fetch-response",\n    BG_UI_UPDATE: "bg-ui-update",\n    BG_CSS_UPDATE: "bg-css-update",\n    CS_COLOR_SCHEME_CHANGE: "cs-color-scheme-change",\n    CS_FRAME_CONNECT: "cs-frame-connect",\n    CS_FRAME_FORGET: "cs-frame-forget",\n    CS_FRAME_FREEZE: "cs-frame-freeze",\n    CS_FRAME_RESUME: "cs-frame-resume",\n    CS_EXPORT_CSS_RESPONSE: "cs-export-css-response",\n    CS_FETCH: "cs-fetch",\n    CS_DARK_THEME_DETECTED: "cs-dark-theme-detected"\n  };\n  let isIFrame = function () {\n    try {\n      return window.self !== window.top;\n    } catch (err) {\n      console.warn(err);\n      return true;\n    }\n  }();\n  const isCSSColorSchemePropSupported = (() => {\n    if (typeof document === "undefined") {\n      return false;\n    }\n    const el = document.createElement("div");\n    el.setAttribute("style", "color-scheme: dark");\n    return el.style && el.style.colorScheme === "dark";\n  })();\n  function logInfo(...args) {}\n  function logWarn(...args) {}\n  var FilterMode;\n  (function (FilterMode) {\n    FilterMode[FilterMode.light = 0] = "light";\n    FilterMode[FilterMode.dark = 1] = "dark";\n  })(FilterMode || (FilterMode = {}));\n  function throttle(callback) {\n    let pending = false;\n    let frameId = null;\n    let lastArgs;\n    const throttled = (...args) => {\n      lastArgs = args;\n      if (frameId) {\n        pending = true;\n      } else {\n        callback(...lastArgs);\n        frameId = requestAnimationFrame(() => {\n          frameId = null;\n          if (pending) {\n            callback(...lastArgs);\n            pending = false;\n          }\n        });\n      }\n    };\n    const cancel = () => {\n      cancelAnimationFrame(frameId);\n      pending = false;\n      frameId = null;\n    };\n    return Object.assign(throttled, {\n      cancel\n    });\n  }\n  function createAsyncTasksQueue() {\n    const tasks = [];\n    let frameId = null;\n    function runTasks() {\n      let task;\n      while (task = tasks.shift()) {\n        task();\n      }\n      frameId = null;\n    }\n    function add(task) {\n      tasks.push(task);\n      if (!frameId) {\n        frameId = requestAnimationFrame(runTasks);\n      }\n    }\n    function cancel() {\n      tasks.splice(0);\n      cancelAnimationFrame(frameId);\n      frameId = null;\n    }\n    return {\n      add,\n      cancel\n    };\n  }\n  function isArrayLike(items) {\n    return items.length != null;\n  }\n  function forEach(items, iterator) {\n    if (isArrayLike(items)) {\n      for (let i = 0, len = items.length; i < len; i++) {\n        iterator(items[i]);\n      }\n    } else {\n      for (const item of items) {\n        iterator(item);\n      }\n    }\n  }\n  function push(array, addition) {\n    forEach(addition, a => array.push(a));\n  }\n  function toArray(items) {\n    const results = [];\n    for (let i = 0, len = items.length; i < len; i++) {\n      results.push(items[i]);\n    }\n    return results;\n  }\n  function getDuration(time) {\n    let duration = 0;\n    if (time.seconds) {\n      duration += time.seconds * 1000;\n    }\n    if (time.minutes) {\n      duration += time.minutes * 60 * 1000;\n    }\n    if (time.hours) {\n      duration += time.hours * 60 * 60 * 1000;\n    }\n    if (time.days) {\n      duration += time.days * 24 * 60 * 60 * 1000;\n    }\n    return duration;\n  }\n  function createNodeAsap({\n    selectNode,\n    createNode,\n    updateNode,\n    selectTarget,\n    createTarget,\n    isTargetMutation\n  }) {\n    const target = selectTarget();\n    if (target) {\n      const prev = selectNode();\n      if (prev) {\n        updateNode(prev);\n      } else {\n        createNode(target);\n      }\n    } else {\n      const observer = new MutationObserver(mutations => {\n        const mutation = mutations.find(isTargetMutation);\n        if (mutation) {\n          unsubscribe();\n          const target = selectTarget();\n          selectNode() || createNode(target);\n        }\n      });\n      const ready = () => {\n        if (document.readyState !== "complete") {\n          return;\n        }\n        unsubscribe();\n        const target = selectTarget() || createTarget();\n        selectNode() || createNode(target);\n      };\n      const unsubscribe = () => {\n        document.removeEventListener("readystatechange", ready);\n        observer.disconnect();\n      };\n      if (document.readyState === "complete") {\n        ready();\n      } else {\n        document.addEventListener("readystatechange", ready);\n        observer.observe(document, {\n          childList: true,\n          subtree: true\n        });\n      }\n    }\n  }\n  function removeNode(node) {\n    node && node.parentNode && node.parentNode.removeChild(node);\n  }\n  function watchForNodePosition(node, mode, onRestore = Function.prototype) {\n    const MAX_ATTEMPTS_COUNT = 10;\n    const RETRY_TIMEOUT = getDuration({\n      seconds: 2\n    });\n    const ATTEMPTS_INTERVAL = getDuration({\n      seconds: 10\n    });\n    const prevSibling = node.previousSibling;\n    let parent = node.parentNode;\n    if (!parent) {\n      throw new Error("Unable to watch for node position: parent element not found");\n    }\n    if (mode === "prev-sibling" && !prevSibling) {\n      throw new Error("Unable to watch for node position: there is no previous sibling");\n    }\n    let attempts = 0;\n    let start = null;\n    let timeoutId = null;\n    const restore = throttle(() => {\n      if (timeoutId) {\n        return;\n      }\n      attempts++;\n      const now = Date.now();\n      if (start == null) {\n        start = now;\n      } else if (attempts >= MAX_ATTEMPTS_COUNT) {\n        if (now - start < ATTEMPTS_INTERVAL) {\n          timeoutId = setTimeout(() => {\n            start = null;\n            attempts = 0;\n            timeoutId = null;\n            restore();\n          }, RETRY_TIMEOUT);\n          return;\n        }\n        start = now;\n        attempts = 1;\n      }\n      if (mode === "parent") {\n        if (prevSibling && prevSibling.parentNode !== parent) {\n          stop();\n          return;\n        }\n      }\n      if (mode === "prev-sibling") {\n        if (prevSibling.parentNode == null) {\n          stop();\n          return;\n        }\n        if (prevSibling.parentNode !== parent) {\n          updateParent(prevSibling.parentNode);\n        }\n      }\n      parent.insertBefore(node, prevSibling ? prevSibling.nextSibling : parent.firstChild);\n      observer.takeRecords();\n      onRestore && onRestore();\n    });\n    const observer = new MutationObserver(() => {\n      if (mode === "parent" && node.parentNode !== parent || mode === "prev-sibling" && node.previousSibling !== prevSibling) {\n        restore();\n      }\n    });\n    const run = () => {\n      observer.observe(parent, {\n        childList: true\n      });\n    };\n    const stop = () => {\n      clearTimeout(timeoutId);\n      observer.disconnect();\n      restore.cancel();\n    };\n    const skip = () => {\n      observer.takeRecords();\n    };\n    const updateParent = parentNode => {\n      parent = parentNode;\n      stop();\n      run();\n    };\n    run();\n    return {\n      run,\n      stop,\n      skip\n    };\n  }\n  function iterateShadowHosts(root, iterator) {\n    if (root == null) {\n      return;\n    }\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n      acceptNode(node) {\n        return node.shadowRoot == null ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n      }\n    });\n    for (let node = root.shadowRoot ? walker.currentNode : walker.nextNode(); node != null; node = walker.nextNode()) {\n      iterator(node);\n      iterateShadowHosts(node.shadowRoot, iterator);\n    }\n  }\n  function setIsDOMReady(newFunc) {\n    isDOMReady = newFunc;\n  }\n  function isDOMReady() {\n    return document.readyState === "complete" || document.readyState === "interactive";\n  }\n  const readyStateListeners = new Set();\n  function addDOMReadyListener(listener) {\n    readyStateListeners.add(listener);\n  }\n  function removeDOMReadyListener(listener) {\n    readyStateListeners.delete(listener);\n  }\n  function isReadyStateComplete() {\n    return document.readyState === "complete";\n  }\n  const readyStateCompleteListeners = new Set();\n  function addReadyStateCompleteListener(listener) {\n    readyStateCompleteListeners.add(listener);\n  }\n  function cleanReadyStateCompleteListeners() {\n    readyStateCompleteListeners.clear();\n  }\n  if (!isDOMReady()) {\n    const onReadyStateChange = () => {\n      if (isDOMReady()) {\n        readyStateListeners.forEach(listener => listener());\n        readyStateListeners.clear();\n        if (isReadyStateComplete()) {\n          document.removeEventListener("readystatechange", onReadyStateChange);\n          readyStateCompleteListeners.forEach(listener => listener());\n          readyStateCompleteListeners.clear();\n        }\n      }\n    };\n    document.addEventListener("readystatechange", onReadyStateChange);\n  }\n  const HUGE_MUTATIONS_COUNT = 1000;\n  function isHugeMutation(mutations) {\n    if (mutations.length > HUGE_MUTATIONS_COUNT) {\n      return true;\n    }\n    let addedNodesCount = 0;\n    for (let i = 0; i < mutations.length; i++) {\n      addedNodesCount += mutations[i].addedNodes.length;\n      if (addedNodesCount > HUGE_MUTATIONS_COUNT) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function getElementsTreeOperations(mutations) {\n    const additions = new Set();\n    const deletions = new Set();\n    const moves = new Set();\n    mutations.forEach(m => {\n      forEach(m.addedNodes, n => {\n        if (n instanceof Element && n.isConnected) {\n          additions.add(n);\n        }\n      });\n      forEach(m.removedNodes, n => {\n        if (n instanceof Element) {\n          if (n.isConnected) {\n            moves.add(n);\n            additions.delete(n);\n          } else {\n            deletions.add(n);\n          }\n        }\n      });\n    });\n    const duplicateAdditions = [];\n    const duplicateDeletions = [];\n    additions.forEach(node => {\n      if (additions.has(node.parentElement)) {\n        duplicateAdditions.push(node);\n      }\n    });\n    deletions.forEach(node => {\n      if (deletions.has(node.parentElement)) {\n        duplicateDeletions.push(node);\n      }\n    });\n    duplicateAdditions.forEach(node => additions.delete(node));\n    duplicateDeletions.forEach(node => deletions.delete(node));\n    return {\n      additions,\n      moves,\n      deletions\n    };\n  }\n  const optimizedTreeObservers = new Map();\n  const optimizedTreeCallbacks = new WeakMap();\n  function createOptimizedTreeObserver(root, callbacks) {\n    let observer;\n    let observerCallbacks;\n    let domReadyListener;\n    if (optimizedTreeObservers.has(root)) {\n      observer = optimizedTreeObservers.get(root);\n      observerCallbacks = optimizedTreeCallbacks.get(observer);\n    } else {\n      let hadHugeMutationsBefore = false;\n      let subscribedForReadyState = false;\n      observer = new MutationObserver(mutations => {\n        if (isHugeMutation(mutations)) {\n          if (!hadHugeMutationsBefore || isDOMReady()) {\n            observerCallbacks.forEach(({\n              onHugeMutations\n            }) => onHugeMutations(root));\n          } else if (!subscribedForReadyState) {\n            domReadyListener = () => observerCallbacks.forEach(({\n              onHugeMutations\n            }) => onHugeMutations(root));\n            addDOMReadyListener(domReadyListener);\n            subscribedForReadyState = true;\n          }\n          hadHugeMutationsBefore = true;\n        } else {\n          const elementsOperations = getElementsTreeOperations(mutations);\n          observerCallbacks.forEach(({\n            onMinorMutations\n          }) => onMinorMutations(elementsOperations));\n        }\n      });\n      observer.observe(root, {\n        childList: true,\n        subtree: true\n      });\n      optimizedTreeObservers.set(root, observer);\n      observerCallbacks = new Set();\n      optimizedTreeCallbacks.set(observer, observerCallbacks);\n    }\n    observerCallbacks.add(callbacks);\n    return {\n      disconnect() {\n        observerCallbacks.delete(callbacks);\n        if (domReadyListener) {\n          removeDOMReadyListener(domReadyListener);\n        }\n        if (observerCallbacks.size === 0) {\n          observer.disconnect();\n          optimizedTreeCallbacks.delete(observer);\n          optimizedTreeObservers.delete(root);\n        }\n      }\n    };\n  }\n  function createOrUpdateStyle$1(css, type) {\n    createNodeAsap({\n      selectNode: () => document.getElementById("dark-reader-style"),\n      createNode: target => {\n        document.documentElement.setAttribute("data-darkreader-mode", type);\n        const style = document.createElement("style");\n        style.id = "dark-reader-style";\n        style.type = "text/css";\n        style.textContent = css;\n        target.appendChild(style);\n      },\n      updateNode: existing => {\n        if (css.replace(/^\\s+/gm, "") !== existing.textContent.replace(/^\\s+/gm, "")) {\n          existing.textContent = css;\n        }\n      },\n      selectTarget: () => document.head,\n      createTarget: () => {\n        const head = document.createElement("head");\n        document.documentElement.insertBefore(head, document.documentElement.firstElementChild);\n        return head;\n      },\n      isTargetMutation: mutation => mutation.target.nodeName.toLowerCase() === "head"\n    });\n  }\n  function removeSVGFilter() {\n    removeNode(document.getElementById("dark-reader-svg"));\n  }\n  function removeStyle() {\n    removeNode(document.getElementById("dark-reader-style"));\n    document.documentElement.removeAttribute("data-darkreader-mode");\n  }\n  const isShadowDomSupported = typeof ShadowRoot === "function";\n  const isMatchMediaChangeEventListenerSupported = typeof MediaQueryList === "function" && typeof MediaQueryList.prototype.addEventListener === "function";\n  (() => {\n    const m = userAgent.match(/chrom[e|ium]\\/([^ ]+)/);\n    if (m && m[1]) {\n      return m[1];\n    }\n    return "";\n  })();\n  const isDefinedSelectorSupported = (() => {\n    try {\n      document.querySelector(":defined");\n      return true;\n    } catch (err) {\n      return false;\n    }\n  })();\n  globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.getManifest && globalThis.chrome.runtime.getManifest().manifest_version === 3;\n  let anchor;\n  const parsedURLCache = new Map();\n  function fixBaseURL($url) {\n    if (!anchor) {\n      anchor = document.createElement("a");\n    }\n    anchor.href = $url;\n    return anchor.href;\n  }\n  function parseURL($url, $base = null) {\n    const key = `${$url}${$base ? `;${$base}` : ""}`;\n    if (parsedURLCache.has(key)) {\n      return parsedURLCache.get(key);\n    }\n    if ($base) {\n      const parsedURL = new URL($url, fixBaseURL($base));\n      parsedURLCache.set(key, parsedURL);\n      return parsedURL;\n    }\n    const parsedURL = new URL(fixBaseURL($url));\n    parsedURLCache.set($url, parsedURL);\n    return parsedURL;\n  }\n  function getAbsoluteURL($base, $relative) {\n    if ($relative.match(/^data\\\\?\\:/)) {\n      return $relative;\n    }\n    if (/^\\/\\//.test($relative)) {\n      return `${location.protocol}${$relative}`;\n    }\n    const b = parseURL($base);\n    const a = parseURL($relative, b.href);\n    return a.href;\n  }\n  function isRelativeHrefOnAbsolutePath(href) {\n    if (href.startsWith("data:")) {\n      return true;\n    }\n    const url = parseURL(href);\n    if (url.protocol !== location.protocol) {\n      return false;\n    }\n    if (url.hostname !== location.hostname) {\n      return false;\n    }\n    if (url.port !== location.port) {\n      return false;\n    }\n    return url.pathname === location.pathname;\n  }\n  function iterateCSSRules(rules, iterate, onMediaRuleError) {\n    forEach(rules, rule => {\n      if (rule.selectorText) {\n        iterate(rule);\n      } else if (rule.href) {\n        try {\n          iterateCSSRules(rule.styleSheet.cssRules, iterate, onMediaRuleError);\n        } catch (err) {\n          onMediaRuleError && onMediaRuleError();\n        }\n      } else if (rule.media) {\n        const media = Array.from(rule.media);\n        const isScreenOrAll = media.some(m => m.startsWith("screen") || m.startsWith("all"));\n        const isPrintOrSpeech = media.some(m => m.startsWith("print") || m.startsWith("speech"));\n        if (isScreenOrAll || !isPrintOrSpeech) {\n          iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);\n        }\n      } else if (rule.conditionText) {\n        if (CSS.supports(rule.conditionText)) {\n          iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);\n        }\n      } else ;\n    });\n  }\n  const shorthandVarDependantProperties = ["background", "border", "border-color", "border-bottom", "border-left", "border-right", "border-top", "outline", "outline-color"];\n  const shorthandVarDepPropRegexps = isSafari ? shorthandVarDependantProperties.map(prop => {\n    const regexp = new RegExp(`${prop}:\\\\s*(.*?)\\\\s*;`);\n    return [prop, regexp];\n  }) : null;\n  function iterateCSSDeclarations(style, iterate) {\n    forEach(style, property => {\n      const value = style.getPropertyValue(property).trim();\n      if (!value) {\n        return;\n      }\n      iterate(property, value);\n    });\n    const cssText = style.cssText;\n    if (cssText.includes("var(")) {\n      if (isSafari) {\n        shorthandVarDepPropRegexps.forEach(([prop, regexp]) => {\n          const match = cssText.match(regexp);\n          if (match && match[1]) {\n            const val = match[1].trim();\n            iterate(prop, val);\n          }\n        });\n      } else {\n        shorthandVarDependantProperties.forEach(prop => {\n          const val = style.getPropertyValue(prop);\n          if (val && val.includes("var(")) {\n            iterate(prop, val);\n          }\n        });\n      }\n    }\n  }\n  const cssURLRegex = /url\\(((\'.+?\')|(".+?")|([^\\)]*?))\\)/g;\n  const cssImportRegex = /@import\\s*(url\\()?((\'.+?\')|(".+?")|([^\\)]*?))\\)?;?/g;\n  function getCSSURLValue(cssURL) {\n    return cssURL.replace(/^url\\((.*)\\)$/, "$1").trim().replace(/^"(.*)"$/, "$1").replace(/^\'(.*)\'$/, "$1");\n  }\n  function getCSSBaseBath(url) {\n    const cssURL = parseURL(url);\n    return `${cssURL.origin}${cssURL.pathname.replace(/\\?.*$/, "").replace(/(\\/)([^\\/]+)$/i, "$1")}`;\n  }\n  function replaceCSSRelativeURLsWithAbsolute($css, cssBasePath) {\n    return $css.replace(cssURLRegex, match => {\n      const pathValue = getCSSURLValue(match);\n      return `url("${getAbsoluteURL(cssBasePath, pathValue)}")`;\n    });\n  }\n  const cssCommentsRegex = /\\/\\*[\\s\\S]*?\\*\\//g;\n  function removeCSSComments($css) {\n    return $css.replace(cssCommentsRegex, "");\n  }\n  const fontFaceRegex = /@font-face\\s*{[^}]*}/g;\n  function replaceCSSFontFace($css) {\n    return $css.replace(fontFaceRegex, "");\n  }\n  function hslToRGB({\n    h,\n    s,\n    l,\n    a = 1\n  }) {\n    if (s === 0) {\n      const [r, b, g] = [l, l, l].map(x => Math.round(x * 255));\n      return {\n        r,\n        g,\n        b,\n        a\n      };\n    }\n    const c = (1 - Math.abs(2 * l - 1)) * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = l - c / 2;\n    const [r, g, b] = (h < 60 ? [c, x, 0] : h < 120 ? [x, c, 0] : h < 180 ? [0, c, x] : h < 240 ? [0, x, c] : h < 300 ? [x, 0, c] : [c, 0, x]).map(n => Math.round((n + m) * 255));\n    return {\n      r,\n      g,\n      b,\n      a\n    };\n  }\n  function rgbToHSL({\n    r: r255,\n    g: g255,\n    b: b255,\n    a = 1\n  }) {\n    const r = r255 / 255;\n    const g = g255 / 255;\n    const b = b255 / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const c = max - min;\n    const l = (max + min) / 2;\n    if (c === 0) {\n      return {\n        h: 0,\n        s: 0,\n        l,\n        a\n      };\n    }\n    let h = (max === r ? (g - b) / c % 6 : max === g ? (b - r) / c + 2 : (r - g) / c + 4) * 60;\n    if (h < 0) {\n      h += 360;\n    }\n    const s = c / (1 - Math.abs(2 * l - 1));\n    return {\n      h,\n      s,\n      l,\n      a\n    };\n  }\n  function toFixed(n, digits = 0) {\n    const fixed = n.toFixed(digits);\n    if (digits === 0) {\n      return fixed;\n    }\n    const dot = fixed.indexOf(".");\n    if (dot >= 0) {\n      const zerosMatch = fixed.match(/0+$/);\n      if (zerosMatch) {\n        if (zerosMatch.index === dot + 1) {\n          return fixed.substring(0, dot);\n        }\n        return fixed.substring(0, zerosMatch.index);\n      }\n    }\n    return fixed;\n  }\n  function rgbToString(rgb) {\n    const {\n      r,\n      g,\n      b,\n      a\n    } = rgb;\n    if (a != null && a < 1) {\n      return `rgba(${toFixed(r)}, ${toFixed(g)}, ${toFixed(b)}, ${toFixed(a, 2)})`;\n    }\n    return `rgb(${toFixed(r)}, ${toFixed(g)}, ${toFixed(b)})`;\n  }\n  function rgbToHexString({\n    r,\n    g,\n    b,\n    a\n  }) {\n    return `#${(a != null && a < 1 ? [r, g, b, Math.round(a * 255)] : [r, g, b]).map(x => {\n      return `${x < 16 ? "0" : ""}${x.toString(16)}`;\n    }).join("")}`;\n  }\n  function hslToString(hsl) {\n    const {\n      h,\n      s,\n      l,\n      a\n    } = hsl;\n    if (a != null && a < 1) {\n      return `hsla(${toFixed(h)}, ${toFixed(s * 100)}%, ${toFixed(l * 100)}%, ${toFixed(a, 2)})`;\n    }\n    return `hsl(${toFixed(h)}, ${toFixed(s * 100)}%, ${toFixed(l * 100)}%)`;\n  }\n  const rgbMatch = /^rgba?\\([^\\(\\)]+\\)$/;\n  const hslMatch = /^hsla?\\([^\\(\\)]+\\)$/;\n  const hexMatch = /^#[0-9a-f]+$/i;\n  function parse($color) {\n    const c = $color.trim().toLowerCase();\n    if (c.match(rgbMatch)) {\n      return parseRGB(c);\n    }\n    if (c.match(hslMatch)) {\n      return parseHSL(c);\n    }\n    if (c.match(hexMatch)) {\n      return parseHex(c);\n    }\n    if (knownColors.has(c)) {\n      return getColorByName(c);\n    }\n    if (systemColors.has(c)) {\n      return getSystemColor(c);\n    }\n    if ($color === "transparent") {\n      return {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n      };\n    }\n    throw new Error(`Unable to parse ${$color}`);\n  }\n  function getNumbers($color) {\n    const numbers = [];\n    let prevPos = 0;\n    let isMining = false;\n    const startIndex = $color.indexOf("(");\n    $color = $color.substring(startIndex + 1, $color.length - 1);\n    for (let i = 0; i < $color.length; i++) {\n      const c = $color[i];\n      if (c >= "0" && c <= "9" || c === "." || c === "+" || c === "-") {\n        isMining = true;\n      } else if (isMining && (c === " " || c === ",")) {\n        numbers.push($color.substring(prevPos, i));\n        isMining = false;\n        prevPos = i + 1;\n      } else if (!isMining) {\n        prevPos = i + 1;\n      }\n    }\n    if (isMining) {\n      numbers.push($color.substring(prevPos, $color.length));\n    }\n    return numbers;\n  }\n  function getNumbersFromString(str, range, units) {\n    const raw = getNumbers(str);\n    const unitsList = Object.entries(units);\n    const numbers = raw.map(r => r.trim()).map((r, i) => {\n      let n;\n      const unit = unitsList.find(([u]) => r.endsWith(u));\n      if (unit) {\n        n = parseFloat(r.substring(0, r.length - unit[0].length)) / unit[1] * range[i];\n      } else {\n        n = parseFloat(r);\n      }\n      if (range[i] > 1) {\n        return Math.round(n);\n      }\n      return n;\n    });\n    return numbers;\n  }\n  const rgbRange = [255, 255, 255, 1];\n  const rgbUnits = {\n    "%": 100\n  };\n  function parseRGB($rgb) {\n    const [r, g, b, a = 1] = getNumbersFromString($rgb, rgbRange, rgbUnits);\n    return {\n      r,\n      g,\n      b,\n      a\n    };\n  }\n  const hslRange = [360, 1, 1, 1];\n  const hslUnits = {\n    "%": 100,\n    "deg": 360,\n    "rad": 2 * Math.PI,\n    "turn": 1\n  };\n  function parseHSL($hsl) {\n    const [h, s, l, a = 1] = getNumbersFromString($hsl, hslRange, hslUnits);\n    return hslToRGB({\n      h,\n      s,\n      l,\n      a\n    });\n  }\n  function parseHex($hex) {\n    const h = $hex.substring(1);\n    switch (h.length) {\n      case 3:\n      case 4:\n        {\n          const [r, g, b] = [0, 1, 2].map(i => parseInt(`${h[i]}${h[i]}`, 16));\n          const a = h.length === 3 ? 1 : parseInt(`${h[3]}${h[3]}`, 16) / 255;\n          return {\n            r,\n            g,\n            b,\n            a\n          };\n        }\n      case 6:\n      case 8:\n        {\n          const [r, g, b] = [0, 2, 4].map(i => parseInt(h.substring(i, i + 2), 16));\n          const a = h.length === 6 ? 1 : parseInt(h.substring(6, 8), 16) / 255;\n          return {\n            r,\n            g,\n            b,\n            a\n          };\n        }\n    }\n    throw new Error(`Unable to parse ${$hex}`);\n  }\n  function getColorByName($color) {\n    const n = knownColors.get($color);\n    return {\n      r: n >> 16 & 255,\n      g: n >> 8 & 255,\n      b: n >> 0 & 255,\n      a: 1\n    };\n  }\n  function getSystemColor($color) {\n    const n = systemColors.get($color);\n    return {\n      r: n >> 16 & 255,\n      g: n >> 8 & 255,\n      b: n >> 0 & 255,\n      a: 1\n    };\n  }\n  const isCharDigit = char => char >= "0" && char <= "9";\n  const getAmountOfDigits = number => Math.floor(Math.log10(number)) + 1;\n  function lowerCalcExpression(color) {\n    let searchIndex = 0;\n    const replaceBetweenIndices = (start, end, replacement) => {\n      color = color.substring(0, start) + replacement + color.substring(end);\n    };\n    const getNumber = () => {\n      let resultNumber = 0;\n      for (let i = 1; i < 4; i++) {\n        const char = color[searchIndex + i];\n        if (char === " ") {\n          break;\n        }\n        if (isCharDigit(char)) {\n          resultNumber *= 10;\n          resultNumber += Number(char);\n        } else {\n          break;\n        }\n      }\n      const lenDigits = getAmountOfDigits(resultNumber);\n      searchIndex += lenDigits;\n      const possibleType = color[searchIndex + 1];\n      if (possibleType !== "%") {\n        return;\n      }\n      searchIndex++;\n      return resultNumber;\n    };\n    while ((searchIndex = color.indexOf("calc(")) !== 0) {\n      const startIndex = searchIndex;\n      searchIndex += 4;\n      const firstNumber = getNumber();\n      if (!firstNumber) {\n        break;\n      }\n      if (color[searchIndex + 1] !== " ") {\n        break;\n      }\n      searchIndex++;\n      const operation = color[searchIndex + 1];\n      if (operation !== "+" && operation !== "-") {\n        break;\n      }\n      searchIndex++;\n      if (color[searchIndex + 1] !== " ") {\n        break;\n      }\n      searchIndex++;\n      const secondNumber = getNumber();\n      if (!secondNumber) {\n        break;\n      }\n      let replacement;\n      if (operation === "+") {\n        replacement = `${firstNumber + secondNumber}%`;\n      } else {\n        replacement = `${firstNumber - secondNumber}%`;\n      }\n      replaceBetweenIndices(startIndex, searchIndex + 2, replacement);\n    }\n    return color;\n  }\n  const knownColors = new Map(Object.entries({\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgrey: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    grey: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgrey: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n  }));\n  const systemColors = new Map(Object.entries({\n    "ActiveBorder": 0x3b99fc,\n    "ActiveCaption": 0x000000,\n    "AppWorkspace": 0xaaaaaa,\n    "Background": 0x6363ce,\n    "ButtonFace": 0xffffff,\n    "ButtonHighlight": 0xe9e9e9,\n    "ButtonShadow": 0x9fa09f,\n    "ButtonText": 0x000000,\n    "CaptionText": 0x000000,\n    "GrayText": 0x7f7f7f,\n    "Highlight": 0xb2d7ff,\n    "HighlightText": 0x000000,\n    "InactiveBorder": 0xffffff,\n    "InactiveCaption": 0xffffff,\n    "InactiveCaptionText": 0x000000,\n    "InfoBackground": 0xfbfcc5,\n    "InfoText": 0x000000,\n    "Menu": 0xf6f6f6,\n    "MenuText": 0xffffff,\n    "Scrollbar": 0xaaaaaa,\n    "ThreeDDarkShadow": 0x000000,\n    "ThreeDFace": 0xc0c0c0,\n    "ThreeDHighlight": 0xffffff,\n    "ThreeDLightShadow": 0xffffff,\n    "ThreeDShadow": 0x000000,\n    "Window": 0xececec,\n    "WindowFrame": 0xaaaaaa,\n    "WindowText": 0x000000,\n    "-webkit-focus-ring-color": 0xe59700\n  }).map(([key, value]) => [key.toLowerCase(), value]));\n  function getSRGBLightness(r, g, b) {\n    return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;\n  }\n  function hasBuiltInDarkTheme() {\n    const drStyles = document.querySelectorAll(".darkreader");\n    drStyles.forEach(style => style.disabled = true);\n    const rootColor = parse(getComputedStyle(document.documentElement).backgroundColor);\n    const bodyColor = document.body ? parse(getComputedStyle(document.body).backgroundColor) : {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0\n    };\n    const rootLightness = 1 - rootColor.a + rootColor.a * getSRGBLightness(rootColor.r, rootColor.g, rootColor.b);\n    const finalLightness = (1 - bodyColor.a) * rootLightness + bodyColor.a * getSRGBLightness(bodyColor.r, bodyColor.g, bodyColor.b);\n    const darkThemeDetected = finalLightness < 0.5;\n    drStyles.forEach(style => style.disabled = false);\n    return darkThemeDetected;\n  }\n  function runCheck(callback) {\n    const darkThemeDetected = hasBuiltInDarkTheme();\n    callback(darkThemeDetected);\n  }\n  function hasSomeStyle() {\n    if (document.documentElement.style.backgroundColor || document.body && document.body.style.backgroundColor) {\n      return true;\n    }\n    for (const style of document.styleSheets) {\n      if (style && style.ownerNode && !style.ownerNode.classList.contains("darkreader")) {\n        return true;\n      }\n    }\n    return false;\n  }\n  let observer$1;\n  let readyStateListener;\n  function runDarkThemeDetector(callback) {\n    stopDarkThemeDetector();\n    if (document.body && hasSomeStyle()) {\n      runCheck(callback);\n      return;\n    }\n    observer$1 = new MutationObserver(() => {\n      if (document.body && hasSomeStyle()) {\n        stopDarkThemeDetector();\n        runCheck(callback);\n      }\n    });\n    observer$1.observe(document.documentElement, {\n      childList: true\n    });\n    if (document.readyState !== "complete") {\n      readyStateListener = () => {\n        if (document.readyState === "complete") {\n          stopDarkThemeDetector();\n          runCheck(callback);\n        }\n      };\n      document.addEventListener("readystatechange", readyStateListener);\n    }\n  }\n  function stopDarkThemeDetector() {\n    if (observer$1) {\n      observer$1.disconnect();\n      observer$1 = null;\n    }\n    if (readyStateListener) {\n      document.removeEventListener("readystatechange", readyStateListener);\n      readyStateListener = null;\n    }\n  }\n  function scale(x, inLow, inHigh, outLow, outHigh) {\n    return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;\n  }\n  function clamp(x, min, max) {\n    return Math.min(max, Math.max(min, x));\n  }\n  function multiplyMatrices(m1, m2) {\n    const result = [];\n    for (let i = 0, len = m1.length; i < len; i++) {\n      result[i] = [];\n      for (let j = 0, len2 = m2[0].length; j < len2; j++) {\n        let sum = 0;\n        for (let k = 0, len3 = m1[0].length; k < len3; k++) {\n          sum += m1[i][k] * m2[k][j];\n        }\n        result[i][j] = sum;\n      }\n    }\n    return result;\n  }\n  function getMatches(regex, input, group = 0) {\n    const matches = [];\n    let m;\n    while (m = regex.exec(input)) {\n      matches.push(m[group]);\n    }\n    return matches;\n  }\n  function formatCSS(text) {\n    function trimLeft(text) {\n      return text.replace(/^\\s+/, "");\n    }\n    function getIndent(depth) {\n      if (depth === 0) {\n        return "";\n      }\n      return " ".repeat(4 * depth);\n    }\n    if (text.length < 50000) {\n      const emptyRuleRegexp = /[^{}]+{\\s*}/;\n      while (emptyRuleRegexp.test(text)) {\n        text = text.replace(emptyRuleRegexp, "");\n      }\n    }\n    const css = text.replace(/\\s{2,}/g, " ").replace(/\\{/g, "{\\n").replace(/\\}/g, "\\n}\\n").replace(/\\;(?![^\\(|\\"]*(\\)|\\"))/g, ";\\n").replace(/\\,(?![^\\(|\\"]*(\\)|\\"))/g, ",\\n").replace(/\\n\\s*\\n/g, "\\n").split("\\n");\n    let depth = 0;\n    const formatted = [];\n    for (let x = 0, len = css.length; x < len; x++) {\n      const line = `${css[x]}\\n`;\n      if (line.includes("{")) {\n        formatted.push(getIndent(depth++) + trimLeft(line));\n      } else if (line.includes("}")) {\n        formatted.push(getIndent(--depth) + trimLeft(line));\n      } else {\n        formatted.push(getIndent(depth) + trimLeft(line));\n      }\n    }\n    return formatted.join("").trim();\n  }\n  function getParenthesesRange(input, searchStartIndex = 0) {\n    const length = input.length;\n    let depth = 0;\n    let firstOpenIndex = -1;\n    for (let i = searchStartIndex; i < length; i++) {\n      if (depth === 0) {\n        const openIndex = input.indexOf("(", i);\n        if (openIndex < 0) {\n          break;\n        }\n        firstOpenIndex = openIndex;\n        depth++;\n        i = openIndex;\n      } else {\n        const closingIndex = input.indexOf(")", i);\n        if (closingIndex < 0) {\n          break;\n        }\n        const openIndex = input.indexOf("(", i);\n        if (openIndex < 0 || closingIndex < openIndex) {\n          depth--;\n          if (depth === 0) {\n            return {\n              start: firstOpenIndex,\n              end: closingIndex + 1\n            };\n          }\n          i = closingIndex;\n        } else {\n          depth++;\n          i = openIndex;\n        }\n      }\n    }\n    return null;\n  }\n  function createFilterMatrix(config) {\n    let m = Matrix.identity();\n    if (config.sepia !== 0) {\n      m = multiplyMatrices(m, Matrix.sepia(config.sepia / 100));\n    }\n    if (config.grayscale !== 0) {\n      m = multiplyMatrices(m, Matrix.grayscale(config.grayscale / 100));\n    }\n    if (config.contrast !== 100) {\n      m = multiplyMatrices(m, Matrix.contrast(config.contrast / 100));\n    }\n    if (config.brightness !== 100) {\n      m = multiplyMatrices(m, Matrix.brightness(config.brightness / 100));\n    }\n    if (config.mode === 1) {\n      m = multiplyMatrices(m, Matrix.invertNHue());\n    }\n    return m;\n  }\n  function applyColorMatrix([r, g, b], matrix) {\n    const rgb = [[r / 255], [g / 255], [b / 255], [1], [1]];\n    const result = multiplyMatrices(matrix, rgb);\n    return [0, 1, 2].map(i => clamp(Math.round(result[i][0] * 255), 0, 255));\n  }\n  const Matrix = {\n    identity() {\n      return [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]];\n    },\n    invertNHue() {\n      return [[0.333, -0.667, -0.667, 0, 1], [-0.667, 0.333, -0.667, 0, 1], [-0.667, -0.667, 0.333, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]];\n    },\n    brightness(v) {\n      return [[v, 0, 0, 0, 0], [0, v, 0, 0, 0], [0, 0, v, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]];\n    },\n    contrast(v) {\n      const t = (1 - v) / 2;\n      return [[v, 0, 0, 0, t], [0, v, 0, 0, t], [0, 0, v, 0, t], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]];\n    },\n    sepia(v) {\n      return [[0.393 + 0.607 * (1 - v), 0.769 - 0.769 * (1 - v), 0.189 - 0.189 * (1 - v), 0, 0], [0.349 - 0.349 * (1 - v), 0.686 + 0.314 * (1 - v), 0.168 - 0.168 * (1 - v), 0, 0], [0.272 - 0.272 * (1 - v), 0.534 - 0.534 * (1 - v), 0.131 + 0.869 * (1 - v), 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]];\n    },\n    grayscale(v) {\n      return [[0.2126 + 0.7874 * (1 - v), 0.7152 - 0.7152 * (1 - v), 0.0722 - 0.0722 * (1 - v), 0, 0], [0.2126 - 0.2126 * (1 - v), 0.7152 + 0.2848 * (1 - v), 0.0722 - 0.0722 * (1 - v), 0, 0], [0.2126 - 0.2126 * (1 - v), 0.7152 - 0.7152 * (1 - v), 0.0722 + 0.9278 * (1 - v), 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]];\n    }\n  };\n  function getBgPole(theme) {\n    const isDarkScheme = theme.mode === 1;\n    const prop = isDarkScheme ? "darkSchemeBackgroundColor" : "lightSchemeBackgroundColor";\n    return theme[prop];\n  }\n  function getFgPole(theme) {\n    const isDarkScheme = theme.mode === 1;\n    const prop = isDarkScheme ? "darkSchemeTextColor" : "lightSchemeTextColor";\n    return theme[prop];\n  }\n  const colorModificationCache = new Map();\n  const colorParseCache$1 = new Map();\n  function parseToHSLWithCache(color) {\n    if (colorParseCache$1.has(color)) {\n      return colorParseCache$1.get(color);\n    }\n    const rgb = parse(color);\n    const hsl = rgbToHSL(rgb);\n    colorParseCache$1.set(color, hsl);\n    return hsl;\n  }\n  function clearColorModificationCache() {\n    colorModificationCache.clear();\n    colorParseCache$1.clear();\n  }\n  const rgbCacheKeys = ["r", "g", "b", "a"];\n  const themeCacheKeys$1 = ["mode", "brightness", "contrast", "grayscale", "sepia", "darkSchemeBackgroundColor", "darkSchemeTextColor", "lightSchemeBackgroundColor", "lightSchemeTextColor"];\n  function getCacheId(rgb, theme) {\n    let resultId = "";\n    rgbCacheKeys.forEach(key => {\n      resultId += `${rgb[key]};`;\n    });\n    themeCacheKeys$1.forEach(key => {\n      resultId += `${theme[key]};`;\n    });\n    return resultId;\n  }\n  function modifyColorWithCache(rgb, theme, modifyHSL, poleColor, anotherPoleColor) {\n    let fnCache;\n    if (colorModificationCache.has(modifyHSL)) {\n      fnCache = colorModificationCache.get(modifyHSL);\n    } else {\n      fnCache = new Map();\n      colorModificationCache.set(modifyHSL, fnCache);\n    }\n    const id = getCacheId(rgb, theme);\n    if (fnCache.has(id)) {\n      return fnCache.get(id);\n    }\n    const hsl = rgbToHSL(rgb);\n    const pole = poleColor == null ? null : parseToHSLWithCache(poleColor);\n    const anotherPole = anotherPoleColor == null ? null : parseToHSLWithCache(anotherPoleColor);\n    const modified = modifyHSL(hsl, pole, anotherPole);\n    const {\n      r,\n      g,\n      b,\n      a\n    } = hslToRGB(modified);\n    const matrix = createFilterMatrix(theme);\n    const [rf, gf, bf] = applyColorMatrix([r, g, b], matrix);\n    const color = a === 1 ? rgbToHexString({\n      r: rf,\n      g: gf,\n      b: bf\n    }) : rgbToString({\n      r: rf,\n      g: gf,\n      b: bf,\n      a\n    });\n    fnCache.set(id, color);\n    return color;\n  }\n  function noopHSL(hsl) {\n    return hsl;\n  }\n  function modifyColor(rgb, theme) {\n    return modifyColorWithCache(rgb, theme, noopHSL);\n  }\n  function modifyLightSchemeColor(rgb, theme) {\n    const poleBg = getBgPole(theme);\n    const poleFg = getFgPole(theme);\n    return modifyColorWithCache(rgb, theme, modifyLightModeHSL, poleFg, poleBg);\n  }\n  function modifyLightModeHSL({\n    h,\n    s,\n    l,\n    a\n  }, poleFg, poleBg) {\n    const isDark = l < 0.5;\n    let isNeutral;\n    if (isDark) {\n      isNeutral = l < 0.2 || s < 0.12;\n    } else {\n      const isBlue = h > 200 && h < 280;\n      isNeutral = s < 0.24 || l > 0.8 && isBlue;\n    }\n    let hx = h;\n    let sx = l;\n    if (isNeutral) {\n      if (isDark) {\n        hx = poleFg.h;\n        sx = poleFg.s;\n      } else {\n        hx = poleBg.h;\n        sx = poleBg.s;\n      }\n    }\n    const lx = scale(l, 0, 1, poleFg.l, poleBg.l);\n    return {\n      h: hx,\n      s: sx,\n      l: lx,\n      a\n    };\n  }\n  const MAX_BG_LIGHTNESS = 0.4;\n  function modifyBgHSL({\n    h,\n    s,\n    l,\n    a\n  }, pole) {\n    const isDark = l < 0.5;\n    const isBlue = h > 200 && h < 280;\n    const isNeutral = s < 0.12 || l > 0.8 && isBlue;\n    if (isDark) {\n      const lx = scale(l, 0, 0.5, 0, MAX_BG_LIGHTNESS);\n      if (isNeutral) {\n        const hx = pole.h;\n        const sx = pole.s;\n        return {\n          h: hx,\n          s: sx,\n          l: lx,\n          a\n        };\n      }\n      return {\n        h,\n        s,\n        l: lx,\n        a\n      };\n    }\n    const lx = scale(l, 0.5, 1, MAX_BG_LIGHTNESS, pole.l);\n    if (isNeutral) {\n      const hx = pole.h;\n      const sx = pole.s;\n      return {\n        h: hx,\n        s: sx,\n        l: lx,\n        a\n      };\n    }\n    let hx = h;\n    const isYellow = h > 60 && h < 180;\n    if (isYellow) {\n      const isCloserToGreen = h > 120;\n      if (isCloserToGreen) {\n        hx = scale(h, 120, 180, 135, 180);\n      } else {\n        hx = scale(h, 60, 120, 60, 105);\n      }\n    }\n    return {\n      h: hx,\n      s,\n      l: lx,\n      a\n    };\n  }\n  function modifyBackgroundColor(rgb, theme) {\n    if (theme.mode === 0) {\n      return modifyLightSchemeColor(rgb, theme);\n    }\n    const pole = getBgPole(theme);\n    return modifyColorWithCache(rgb, {\n      ...theme,\n      mode: 0\n    }, modifyBgHSL, pole);\n  }\n  const MIN_FG_LIGHTNESS = 0.55;\n  function modifyBlueFgHue(hue) {\n    return scale(hue, 205, 245, 205, 220);\n  }\n  function modifyFgHSL({\n    h,\n    s,\n    l,\n    a\n  }, pole) {\n    const isLight = l > 0.5;\n    const isNeutral = l < 0.2 || s < 0.24;\n    const isBlue = !isNeutral && h > 205 && h < 245;\n    if (isLight) {\n      const lx = scale(l, 0.5, 1, MIN_FG_LIGHTNESS, pole.l);\n      if (isNeutral) {\n        const hx = pole.h;\n        const sx = pole.s;\n        return {\n          h: hx,\n          s: sx,\n          l: lx,\n          a\n        };\n      }\n      let hx = h;\n      if (isBlue) {\n        hx = modifyBlueFgHue(h);\n      }\n      return {\n        h: hx,\n        s,\n        l: lx,\n        a\n      };\n    }\n    if (isNeutral) {\n      const hx = pole.h;\n      const sx = pole.s;\n      const lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);\n      return {\n        h: hx,\n        s: sx,\n        l: lx,\n        a\n      };\n    }\n    let hx = h;\n    let lx;\n    if (isBlue) {\n      hx = modifyBlueFgHue(h);\n      lx = scale(l, 0, 0.5, pole.l, Math.min(1, MIN_FG_LIGHTNESS + 0.05));\n    } else {\n      lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);\n    }\n    return {\n      h: hx,\n      s,\n      l: lx,\n      a\n    };\n  }\n  function modifyForegroundColor(rgb, theme) {\n    if (theme.mode === 0) {\n      return modifyLightSchemeColor(rgb, theme);\n    }\n    const pole = getFgPole(theme);\n    return modifyColorWithCache(rgb, {\n      ...theme,\n      mode: 0\n    }, modifyFgHSL, pole);\n  }\n  function modifyBorderHSL({\n    h,\n    s,\n    l,\n    a\n  }, poleFg, poleBg) {\n    const isDark = l < 0.5;\n    const isNeutral = l < 0.2 || s < 0.24;\n    let hx = h;\n    let sx = s;\n    if (isNeutral) {\n      if (isDark) {\n        hx = poleFg.h;\n        sx = poleFg.s;\n      } else {\n        hx = poleBg.h;\n        sx = poleBg.s;\n      }\n    }\n    const lx = scale(l, 0, 1, 0.5, 0.2);\n    return {\n      h: hx,\n      s: sx,\n      l: lx,\n      a\n    };\n  }\n  function modifyBorderColor(rgb, theme) {\n    if (theme.mode === 0) {\n      return modifyLightSchemeColor(rgb, theme);\n    }\n    const poleFg = getFgPole(theme);\n    const poleBg = getBgPole(theme);\n    return modifyColorWithCache(rgb, {\n      ...theme,\n      mode: 0\n    }, modifyBorderHSL, poleFg, poleBg);\n  }\n  function modifyShadowColor(rgb, filter) {\n    return modifyBackgroundColor(rgb, filter);\n  }\n  function modifyGradientColor(rgb, filter) {\n    return modifyBackgroundColor(rgb, filter);\n  }\n  function createTextStyle(config) {\n    const lines = [];\n    lines.push(\'*:not(pre, pre *, code, .far, .fa, .glyphicon, [class*="vjs-"], .fab, .fa-github, .fas, .material-icons, .icofont, .typcn, mu, [class*="mu-"], .glyphicon, .icon) {\');\n    if (config.useFont && config.fontFamily) {\n      lines.push(`  font-family: ${config.fontFamily} !important;`);\n    }\n    if (config.textStroke > 0) {\n      lines.push(`  -webkit-text-stroke: ${config.textStroke}px !important;`);\n      lines.push(`  text-stroke: ${config.textStroke}px !important;`);\n    }\n    lines.push("}");\n    return lines.join("\\n");\n  }\n  function getCSSFilterValue(config) {\n    const filters = [];\n    if (config.mode === FilterMode.dark) {\n      filters.push("invert(100%) hue-rotate(180deg)");\n    }\n    if (config.brightness !== 100) {\n      filters.push(`brightness(${config.brightness}%)`);\n    }\n    if (config.contrast !== 100) {\n      filters.push(`contrast(${config.contrast}%)`);\n    }\n    if (config.grayscale !== 0) {\n      filters.push(`grayscale(${config.grayscale}%)`);\n    }\n    if (config.sepia !== 0) {\n      filters.push(`sepia(${config.sepia}%)`);\n    }\n    if (filters.length === 0) {\n      return null;\n    }\n    return filters.join(" ");\n  }\n  function toSVGMatrix(matrix) {\n    return matrix.slice(0, 4).map(m => m.map(m => m.toFixed(3)).join(" ")).join(" ");\n  }\n  function getSVGFilterMatrixValue(config) {\n    return toSVGMatrix(createFilterMatrix(config));\n  }\n  let counter = 0;\n  const resolvers$1 = new Map();\n  const rejectors = new Map();\n  async function bgFetch(request) {\n    return new Promise((resolve, reject) => {\n      const id = ++counter;\n      resolvers$1.set(id, resolve);\n      rejectors.set(id, reject);\n      browser.runtime.sendMessage({\n        from: "bootstrap",\n        operate: MessageType.CS_FETCH,\n        data: request,\n        id\n      });\n    });\n  }\n  async function getOKResponse(url, mimeType, origin) {\n    const response = await fetch(url, {\n      cache: "force-cache",\n      credentials: "omit",\n      referrer: origin\n    });\n    if (isSafari && mimeType === "text/css" && url.startsWith("safari-web-extension://") && url.endsWith(".css")) {\n      return response;\n    }\n    if (mimeType && !response.headers.get("Content-Type").startsWith(mimeType)) {\n      throw new Error(`Mime type mismatch when loading ${url}`);\n    }\n    if (!response.ok) {\n      throw new Error(`Unable to load ${url} ${response.status} ${response.statusText}`);\n    }\n    return response;\n  }\n  async function loadAsDataURL(url, mimeType) {\n    const response = await getOKResponse(url, mimeType);\n    return await readResponseAsDataURL(response);\n  }\n  async function readResponseAsDataURL(response) {\n    const blob = await response.blob();\n    const dataURL = await new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onloadend = () => resolve(reader.result);\n      reader.readAsDataURL(blob);\n    });\n    return dataURL;\n  }\n  class AsyncQueue {\n    constructor() {\n      this.queue = [];\n      this.timerId = null;\n      this.frameDuration = 1000 / 60;\n    }\n    addToQueue(entry) {\n      this.queue.push(entry);\n      this.startQueue();\n    }\n    stopQueue() {\n      if (this.timerId !== null) {\n        cancelAnimationFrame(this.timerId);\n        this.timerId = null;\n      }\n      this.queue = [];\n    }\n    startQueue() {\n      if (this.timerId) {\n        return;\n      }\n      this.timerId = requestAnimationFrame(() => {\n        this.timerId = null;\n        const start = Date.now();\n        let cb;\n        while (cb = this.queue.shift()) {\n          cb();\n          if (Date.now() - start >= this.frameDuration) {\n            this.startQueue();\n            break;\n          }\n        }\n      });\n    }\n  }\n  const imageManager = new AsyncQueue();\n  async function getImageDetails(url) {\n    return new Promise(async (resolve, reject) => {\n      let dataURL;\n      if (url.startsWith("data:")) {\n        dataURL = url;\n      } else {\n        try {\n          dataURL = await getImageDataURL(url);\n        } catch (error) {\n          reject(error);\n          return;\n        }\n      }\n      try {\n        const image = await urlToImage(dataURL);\n        imageManager.addToQueue(() => {\n          resolve({\n            src: url,\n            dataURL,\n            width: image.naturalWidth,\n            height: image.naturalHeight,\n            ...analyzeImage(image)\n          });\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  async function getImageDataURL(url) {\n    const parsedURL = new URL(url);\n    if (parsedURL.origin === location.origin) {\n      return await loadAsDataURL(url);\n    }\n    return await bgFetch({\n      url,\n      responseType: "data-url"\n    });\n  }\n  async function urlToImage(url) {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.onerror = () => reject(`Unable to load image ${url}`);\n      image.src = url;\n    });\n  }\n  const MAX_ANALIZE_PIXELS_COUNT = 32 * 32;\n  let canvas;\n  let context;\n  function createCanvas() {\n    const maxWidth = MAX_ANALIZE_PIXELS_COUNT;\n    const maxHeight = MAX_ANALIZE_PIXELS_COUNT;\n    canvas = document.createElement("canvas");\n    canvas.width = maxWidth;\n    canvas.height = maxHeight;\n    context = canvas.getContext("2d");\n    if (context) {\n      context.imageSmoothingEnabled = false;\n    }\n  }\n  function removeCanvas() {\n    canvas = null;\n    context = null;\n  }\n  const MAX_IMAGE_SIZE = 5 * 1024 * 1024;\n  function analyzeImage(image) {\n    if (!canvas) {\n      createCanvas();\n    }\n    if (!context) {\n      return {\n        isDark: false,\n        isLight: true,\n        isTransparent: false,\n        isLarge: true,\n        isTooLarge: false\n      };\n    }\n    const {\n      naturalWidth,\n      naturalHeight\n    } = image;\n    if (naturalHeight === 0 || naturalWidth === 0) {\n      logWarn(`logWarn(Image is empty ${image.currentSrc})`);\n      return null;\n    }\n    const size = naturalWidth * naturalHeight * 4;\n    if (size > MAX_IMAGE_SIZE) {\n      return {\n        isDark: false,\n        isLight: false,\n        isTransparent: false,\n        isLarge: false,\n        isTooLarge: false\n      };\n    }\n    const naturalPixelsCount = naturalWidth * naturalHeight;\n    const k = Math.min(1, Math.sqrt(MAX_ANALIZE_PIXELS_COUNT / naturalPixelsCount));\n    const width = Math.ceil(naturalWidth * k);\n    const height = Math.ceil(naturalHeight * k);\n    context.clearRect(0, 0, width, height);\n    context.drawImage(image, 0, 0, naturalWidth, naturalHeight, 0, 0, width, height);\n    const imageData = context.getImageData(0, 0, width, height);\n    const d = imageData.data;\n    const TRANSPARENT_ALPHA_THRESHOLD = 0.05;\n    const DARK_LIGHTNESS_THRESHOLD = 0.4;\n    const LIGHT_LIGHTNESS_THRESHOLD = 0.7;\n    let transparentPixelsCount = 0;\n    let darkPixelsCount = 0;\n    let lightPixelsCount = 0;\n    let i, x, y;\n    let r, g, b, a;\n    let l;\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width; x++) {\n        i = 4 * (y * width + x);\n        r = d[i + 0] / 255;\n        g = d[i + 1] / 255;\n        b = d[i + 2] / 255;\n        a = d[i + 3] / 255;\n        if (a < TRANSPARENT_ALPHA_THRESHOLD) {\n          transparentPixelsCount++;\n        } else {\n          l = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n          if (l < DARK_LIGHTNESS_THRESHOLD) {\n            darkPixelsCount++;\n          }\n          if (l > LIGHT_LIGHTNESS_THRESHOLD) {\n            lightPixelsCount++;\n          }\n        }\n      }\n    }\n    const totalPixelsCount = width * height;\n    const opaquePixelsCount = totalPixelsCount - transparentPixelsCount;\n    const DARK_IMAGE_THRESHOLD = 0.7;\n    const LIGHT_IMAGE_THRESHOLD = 0.7;\n    const TRANSPARENT_IMAGE_THRESHOLD = 0.1;\n    const LARGE_IMAGE_PIXELS_COUNT = 800 * 600;\n    return {\n      isDark: darkPixelsCount / opaquePixelsCount >= DARK_IMAGE_THRESHOLD,\n      isLight: lightPixelsCount / opaquePixelsCount >= LIGHT_IMAGE_THRESHOLD,\n      isTransparent: transparentPixelsCount / totalPixelsCount >= TRANSPARENT_IMAGE_THRESHOLD,\n      isLarge: naturalPixelsCount >= LARGE_IMAGE_PIXELS_COUNT,\n      isTooLarge: false\n    };\n  }\n  function getFilteredImageDataURL({\n    dataURL,\n    width,\n    height\n  }, theme) {\n    const matrix = getSVGFilterMatrixValue(theme);\n    const svg = [`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${width}" height="${height}">`, "<defs>", \'<filter id="darkreader-image-filter">\', `<feColorMatrix type="matrix" values="${matrix}" />`, "</filter>", "</defs>", `<image width="${width}" height="${height}" filter="url(#darkreader-image-filter)" xlink:href="${dataURL}" />`, "</svg>"].join("");\n    return `data:image/svg+xml;base64,${btoa(svg)}`;\n  }\n  function cleanImageProcessingCache() {\n    imageManager && imageManager.stopQueue();\n    removeCanvas();\n  }\n  function getPriority(ruleStyle, property) {\n    return Boolean(ruleStyle && ruleStyle.getPropertyPriority(property));\n  }\n  function getModifiableCSSDeclaration(property, value, rule, variablesStore, ignoreImageSelectors, isCancelled) {\n    if (property.startsWith("--")) {\n      const modifier = getVariableModifier(variablesStore, property, value, rule, ignoreImageSelectors, isCancelled);\n      if (modifier) {\n        return {\n          property,\n          value: modifier,\n          important: getPriority(rule.style, property),\n          sourceValue: value\n        };\n      }\n    } else if (value.includes("var(")) {\n      const modifier = getVariableDependantModifier(variablesStore, property, value);\n      if (modifier) {\n        return {\n          property,\n          value: modifier,\n          important: getPriority(rule.style, property),\n          sourceValue: value\n        };\n      }\n    } else if (property.includes("color") && property !== "-webkit-print-color-adjust" || property === "fill" || property === "stroke" || property === "stop-color") {\n      const modifier = getColorModifier(property, value);\n      if (modifier) {\n        return {\n          property,\n          value: modifier,\n          important: getPriority(rule.style, property),\n          sourceValue: value\n        };\n      }\n    } else if (property === "background-image" || property === "list-style-image") {\n      const modifier = getBgImageModifier(value, rule, ignoreImageSelectors, isCancelled);\n      if (modifier) {\n        return {\n          property,\n          value: modifier,\n          important: getPriority(rule.style, property),\n          sourceValue: value\n        };\n      }\n    } else if (property.includes("shadow")) {\n      const modifier = getShadowModifier(value);\n      if (modifier) {\n        return {\n          property,\n          value: modifier,\n          important: getPriority(rule.style, property),\n          sourceValue: value\n        };\n      }\n    }\n    return null;\n  }\n  function joinSelectors(...selectors) {\n    return selectors.filter(Boolean).join(", ");\n  }\n  function getModifiedUserAgentStyle(theme, isIFrame, styleSystemControls) {\n    const lines = [];\n    if (!isIFrame) {\n      lines.push("html {");\n      lines.push(`    background-color: ${modifyBackgroundColor({\n        r: 255,\n        g: 255,\n        b: 255\n      }, theme)} !important;`);\n      lines.push("}");\n    }\n    if (isCSSColorSchemePropSupported) {\n      lines.push("html {");\n      lines.push(`    color-scheme: ${theme.mode === 1 ? "dark" : "dark light"} !important;`);\n      lines.push("}");\n    }\n    const bgSelectors = joinSelectors(isIFrame ? "" : "html, body", styleSystemControls ? "input, textarea, select, button" : "");\n    if (bgSelectors) {\n      lines.push(`${bgSelectors} {`);\n      lines.push(`    background-color: ${modifyBackgroundColor({\n        r: 255,\n        g: 255,\n        b: 255\n      }, theme)};`);\n      lines.push("}");\n    }\n    lines.push(`${joinSelectors("html, body", styleSystemControls ? "input, textarea, select, button" : "")} {`);\n    lines.push(`    border-color: ${modifyBorderColor({\n      r: 76,\n      g: 76,\n      b: 76\n    }, theme)};`);\n    lines.push(`    color: ${modifyForegroundColor({\n      r: 0,\n      g: 0,\n      b: 0\n    }, theme)};`);\n    lines.push("}");\n    lines.push("a {");\n    lines.push(`    color: ${modifyForegroundColor({\n      r: 0,\n      g: 64,\n      b: 255\n    }, theme)};`);\n    lines.push("}");\n    lines.push("table {");\n    lines.push(`    border-color: ${modifyBorderColor({\n      r: 128,\n      g: 128,\n      b: 128\n    }, theme)};`);\n    lines.push("}");\n    lines.push("::placeholder {");\n    lines.push(`    color: ${modifyForegroundColor({\n      r: 169,\n      g: 169,\n      b: 169\n    }, theme)};`);\n    lines.push("}");\n    lines.push("input:-webkit-autofill,");\n    lines.push("textarea:-webkit-autofill,");\n    lines.push("select:-webkit-autofill {");\n    lines.push(`    background-color: ${modifyBackgroundColor({\n      r: 250,\n      g: 255,\n      b: 189\n    }, theme)} !important;`);\n    lines.push(`    color: ${modifyForegroundColor({\n      r: 0,\n      g: 0,\n      b: 0\n    }, theme)} !important;`);\n    lines.push("}");\n    if (theme.scrollbarColor) {\n      lines.push(getModifiedScrollbarStyle(theme));\n    }\n    if (theme.selectionColor) {\n      lines.push(getModifiedSelectionStyle(theme));\n    }\n    return lines.join("\\n");\n  }\n  function getSelectionColor(theme) {\n    let backgroundColorSelection;\n    let foregroundColorSelection;\n    if (theme.selectionColor === "auto") {\n      backgroundColorSelection = modifyBackgroundColor({\n        r: 0,\n        g: 96,\n        b: 212\n      }, {\n        ...theme,\n        grayscale: 0\n      });\n      foregroundColorSelection = modifyForegroundColor({\n        r: 255,\n        g: 255,\n        b: 255\n      }, {\n        ...theme,\n        grayscale: 0\n      });\n    } else {\n      const rgb = parse(theme.selectionColor);\n      const hsl = rgbToHSL(rgb);\n      backgroundColorSelection = theme.selectionColor;\n      if (hsl.l < 0.5) {\n        foregroundColorSelection = "#FFF";\n      } else {\n        foregroundColorSelection = "#000";\n      }\n    }\n    return {\n      backgroundColorSelection,\n      foregroundColorSelection\n    };\n  }\n  function getModifiedSelectionStyle(theme) {\n    const lines = [];\n    const modifiedSelectionColor = getSelectionColor(theme);\n    const backgroundColorSelection = modifiedSelectionColor.backgroundColorSelection;\n    const foregroundColorSelection = modifiedSelectionColor.foregroundColorSelection;\n    ["::selection", "::-moz-selection"].forEach(selection => {\n      lines.push(`${selection} {`);\n      lines.push(`    background-color: ${backgroundColorSelection} !important;`);\n      lines.push(`    color: ${foregroundColorSelection} !important;`);\n      lines.push("}");\n    });\n    return lines.join("\\n");\n  }\n  function getModifiedScrollbarStyle(theme) {\n    const lines = [];\n    let colorTrack;\n    let colorIcons;\n    let colorThumb;\n    let colorThumbHover;\n    let colorThumbActive;\n    let colorCorner;\n    if (theme.scrollbarColor === "auto") {\n      colorTrack = modifyBackgroundColor({\n        r: 241,\n        g: 241,\n        b: 241\n      }, theme);\n      colorIcons = modifyForegroundColor({\n        r: 96,\n        g: 96,\n        b: 96\n      }, theme);\n      colorThumb = modifyBackgroundColor({\n        r: 176,\n        g: 176,\n        b: 176\n      }, theme);\n      colorThumbHover = modifyBackgroundColor({\n        r: 144,\n        g: 144,\n        b: 144\n      }, theme);\n      colorThumbActive = modifyBackgroundColor({\n        r: 96,\n        g: 96,\n        b: 96\n      }, theme);\n      colorCorner = modifyBackgroundColor({\n        r: 255,\n        g: 255,\n        b: 255\n      }, theme);\n    } else {\n      const rgb = parse(theme.scrollbarColor);\n      const hsl = rgbToHSL(rgb);\n      const isLight = hsl.l > 0.5;\n      const lighten = lighter => ({\n        ...hsl,\n        l: clamp(hsl.l + lighter, 0, 1)\n      });\n      const darken = darker => ({\n        ...hsl,\n        l: clamp(hsl.l - darker, 0, 1)\n      });\n      colorTrack = hslToString(darken(0.4));\n      colorIcons = hslToString(isLight ? darken(0.4) : lighten(0.4));\n      colorThumb = hslToString(hsl);\n      colorThumbHover = hslToString(lighten(0.1));\n      colorThumbActive = hslToString(lighten(0.2));\n    }\n    lines.push("::-webkit-scrollbar {");\n    lines.push(`    background-color: ${colorTrack};`);\n    lines.push(`    color: ${colorIcons};`);\n    lines.push("}");\n    lines.push("::-webkit-scrollbar-thumb {");\n    lines.push(`    background-color: ${colorThumb};`);\n    lines.push("}");\n    lines.push("::-webkit-scrollbar-thumb:hover {");\n    lines.push(`    background-color: ${colorThumbHover};`);\n    lines.push("}");\n    lines.push("::-webkit-scrollbar-thumb:active {");\n    lines.push(`    background-color: ${colorThumbActive};`);\n    lines.push("}");\n    lines.push("::-webkit-scrollbar-corner {");\n    lines.push(`    background-color: ${colorCorner};`);\n    lines.push("}");\n    if (isSafari) {\n      lines.push("* {");\n      lines.push(`    scrollbar-color: ${colorThumb} ${colorTrack};`);\n      lines.push("}");\n    }\n    return lines.join("\\n");\n  }\n  function getModifiedFallbackStyle(filter, {\n    strict\n  }) {\n    const lines = [];\n    const isMicrosoft = location.hostname.endsWith("microsoft.com");\n    lines.push(`html, body, ${strict ? `body :not(iframe)${isMicrosoft ? \':not(div[style^="position:absolute;top:0;left:-"]\' : ""}` : "body > :not(iframe)"} {`);\n    lines.push(`    background-color: ${modifyBackgroundColor({\n      r: 255,\n      g: 255,\n      b: 255\n    }, filter)} !important;`);\n    lines.push(`    border-color: ${modifyBorderColor({\n      r: 64,\n      g: 64,\n      b: 64\n    }, filter)} !important;`);\n    lines.push(`    color: ${modifyForegroundColor({\n      r: 0,\n      g: 0,\n      b: 0\n    }, filter)} !important;`);\n    lines.push("}");\n    return lines.join("\\n");\n  }\n  const unparsableColors = new Set(["inherit", "transparent", "initial", "currentcolor", "none", "unset"]);\n  const colorParseCache = new Map();\n  function parseColorWithCache($color) {\n    $color = $color.trim();\n    if (colorParseCache.has($color)) {\n      return colorParseCache.get($color);\n    }\n    if ($color.includes("calc(")) {\n      $color = lowerCalcExpression($color);\n    }\n    const color = parse($color);\n    colorParseCache.set($color, color);\n    return color;\n  }\n  function tryParseColor($color) {\n    try {\n      return parseColorWithCache($color);\n    } catch (err) {\n      return null;\n    }\n  }\n  function getColorModifier(prop, value) {\n    if (unparsableColors.has(value.toLowerCase())) {\n      return value;\n    }\n    try {\n      const rgb = parseColorWithCache(value);\n      if (prop.includes("background")) {\n        return filter => modifyBackgroundColor(rgb, filter);\n      }\n      if (prop.includes("border") || prop.includes("outline")) {\n        return filter => modifyBorderColor(rgb, filter);\n      }\n      return filter => modifyForegroundColor(rgb, filter);\n    } catch (err) {\n      return null;\n    }\n  }\n  const gradientRegex = /[\\-a-z]+gradient\\(([^\\(\\)]*(\\(([^\\(\\)]*(\\(.*?\\)))*[^\\(\\)]*\\))){0,15}[^\\(\\)]*\\)/g;\n  const imageDetailsCache = new Map();\n  const awaitingForImageLoading = new Map();\n  function shouldIgnoreImage(selectorText, selectors) {\n    if (!selectorText || selectors.length === 0) {\n      return false;\n    }\n    if (selectors.some(s => s === "*")) {\n      return true;\n    }\n    const ruleSelectors = selectorText.split(/,\\s*/g);\n    for (let i = 0; i < selectors.length; i++) {\n      const ignoredSelector = selectors[i];\n      if (ruleSelectors.some(s => s === ignoredSelector)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function getBgImageModifier(value, rule, ignoreImageSelectors, isCancelled) {\n    try {\n      const gradients = getMatches(gradientRegex, value);\n      const urls = getMatches(cssURLRegex, value);\n      if (urls.length === 0 && gradients.length === 0) {\n        return value;\n      }\n      const getIndices = matches => {\n        let index = 0;\n        return matches.map(match => {\n          const valueIndex = value.indexOf(match, index);\n          index = valueIndex + match.length;\n          return {\n            match,\n            index: valueIndex\n          };\n        });\n      };\n      const matches = getIndices(urls).map(i => ({\n        type: "url",\n        ...i\n      })).concat(getIndices(gradients).map(i => ({\n        type: "gradient",\n        ...i\n      }))).sort((a, b) => a.index - b.index);\n      const getGradientModifier = gradient => {\n        const match = gradient.match(/^(.*-gradient)\\((.*)\\)$/);\n        const type = match[1];\n        const content = match[2];\n        const partsRegex = /([^\\(\\),]+(\\([^\\(\\)]*(\\([^\\(\\)]*\\)*[^\\(\\)]*)?\\))?[^\\(\\),]*),?/g;\n        const colorStopRegex = /^(from|color-stop|to)\\(([^\\(\\)]*?,\\s*)?(.*?)\\)$/;\n        const parts = getMatches(partsRegex, content, 1).map(part => {\n          part = part.trim();\n          let rgb = tryParseColor(part);\n          if (rgb) {\n            return filter => modifyGradientColor(rgb, filter);\n          }\n          const space = part.lastIndexOf(" ");\n          rgb = tryParseColor(part.substring(0, space));\n          if (rgb) {\n            return filter => `${modifyGradientColor(rgb, filter)} ${part.substring(space + 1)}`;\n          }\n          const colorStopMatch = part.match(colorStopRegex);\n          if (colorStopMatch) {\n            rgb = tryParseColor(colorStopMatch[3]);\n            if (rgb) {\n              return filter => `${colorStopMatch[1]}(${colorStopMatch[2] ? `${colorStopMatch[2]}, ` : ""}${modifyGradientColor(rgb, filter)})`;\n            }\n          }\n          return () => part;\n        });\n        return filter => {\n          return `${type}(${parts.map(modify => modify(filter)).join(", ")})`;\n        };\n      };\n      const getURLModifier = urlValue => {\n        var _a;\n        if (shouldIgnoreImage(rule.selectorText, ignoreImageSelectors)) {\n          return null;\n        }\n        let url = getCSSURLValue(urlValue);\n        const {\n          parentStyleSheet\n        } = rule;\n        const baseURL = parentStyleSheet && parentStyleSheet.href ? getCSSBaseBath(parentStyleSheet.href) : ((_a = parentStyleSheet.ownerNode) === null || _a === void 0 ? void 0 : _a.baseURI) || location.origin;\n        url = getAbsoluteURL(baseURL, url);\n        const absoluteValue = `url("${url}")`;\n        return async filter => {\n          let imageDetails;\n          if (imageDetailsCache.has(url)) {\n            imageDetails = imageDetailsCache.get(url);\n          } else {\n            try {\n              if (awaitingForImageLoading.has(url)) {\n                const awaiters = awaitingForImageLoading.get(url);\n                imageDetails = await new Promise(resolve => awaiters.push(resolve));\n                if (!imageDetails) {\n                  return null;\n                }\n              } else {\n                awaitingForImageLoading.set(url, []);\n                imageDetails = await getImageDetails(url);\n                imageDetailsCache.set(url, imageDetails);\n                awaitingForImageLoading.get(url).forEach(resolve => resolve(imageDetails));\n                awaitingForImageLoading.delete(url);\n              }\n              if (isCancelled()) {\n                return null;\n              }\n            } catch (err) {\n              logWarn(err);\n              if (awaitingForImageLoading.has(url)) {\n                awaitingForImageLoading.get(url).forEach(resolve => resolve(null));\n                awaitingForImageLoading.delete(url);\n              }\n              return absoluteValue;\n            }\n          }\n          const bgImageValue = getBgImageValue(imageDetails, filter) || absoluteValue;\n          return bgImageValue;\n        };\n      };\n      const getBgImageValue = (imageDetails, filter) => {\n        const {\n          isDark,\n          isLight,\n          isTransparent,\n          isLarge,\n          isTooLarge,\n          width\n        } = imageDetails;\n        let result;\n        if (isTooLarge) {\n          result = `url("${imageDetails.src}")`;\n        } else if (isDark && isTransparent && filter.mode === 1 && !isLarge && width > 2) {\n          logInfo(`Inverting dark image ${imageDetails.src}`);\n          const inverted = getFilteredImageDataURL(imageDetails, {\n            ...filter,\n            sepia: clamp(filter.sepia + 10, 0, 100)\n          });\n          result = `url("${inverted}")`;\n        } else if (isLight && !isTransparent && filter.mode === 1) {\n          if (isLarge) {\n            result = "none";\n          } else {\n            logInfo(`Dimming light image ${imageDetails.src}`);\n            const dimmed = getFilteredImageDataURL(imageDetails, filter);\n            result = `url("${dimmed}")`;\n          }\n        } else if (filter.mode === 0 && isLight && !isLarge) {\n          logInfo(`Applying filter to image ${imageDetails.src}`);\n          const filtered = getFilteredImageDataURL(imageDetails, {\n            ...filter,\n            brightness: clamp(filter.brightness - 10, 5, 200),\n            sepia: clamp(filter.sepia + 10, 0, 100)\n          });\n          result = `url("${filtered}")`;\n        } else {\n          result = null;\n        }\n        return result;\n      };\n      const modifiers = [];\n      let index = 0;\n      matches.forEach(({\n        match,\n        type,\n        index: matchStart\n      }, i) => {\n        const prefixStart = index;\n        const matchEnd = matchStart + match.length;\n        index = matchEnd;\n        modifiers.push(() => value.substring(prefixStart, matchStart));\n        modifiers.push(type === "url" ? getURLModifier(match) : getGradientModifier(match));\n        if (i === matches.length - 1) {\n          modifiers.push(() => value.substring(matchEnd));\n        }\n      });\n      return filter => {\n        const results = modifiers.filter(Boolean).map(modify => modify(filter));\n        if (results.some(r => r instanceof Promise)) {\n          return Promise.all(results).then(asyncResults => {\n            return asyncResults.join("");\n          });\n        }\n        return results.join("");\n      };\n    } catch (err) {\n      return null;\n    }\n  }\n  function getShadowModifierWithInfo(value) {\n    try {\n      let index = 0;\n      const colorMatches = getMatches(/(^|\\s)(?!calc)([a-z]+\\(.+?\\)|#[0-9a-f]+|[a-z]+)(.*?(inset|outset)?($|,))/gi, value, 2);\n      let notParsed = 0;\n      const modifiers = colorMatches.map((match, i) => {\n        const prefixIndex = index;\n        const matchIndex = value.indexOf(match, index);\n        const matchEnd = matchIndex + match.length;\n        index = matchEnd;\n        const rgb = tryParseColor(match);\n        if (!rgb) {\n          notParsed++;\n          return () => value.substring(prefixIndex, matchEnd);\n        }\n        return filter => `${value.substring(prefixIndex, matchIndex)}${modifyShadowColor(rgb, filter)}${i === colorMatches.length - 1 ? value.substring(matchEnd) : ""}`;\n      });\n      return filter => {\n        const modified = modifiers.map(modify => modify(filter)).join("");\n        return {\n          matchesLength: colorMatches.length,\n          unparseableMatchesLength: notParsed,\n          result: modified\n        };\n      };\n    } catch (err) {\n      return null;\n    }\n  }\n  function getShadowModifier(value) {\n    const shadowModifier = getShadowModifierWithInfo(value);\n    if (!shadowModifier) {\n      return null;\n    }\n    return theme => shadowModifier(theme).result;\n  }\n  function getVariableModifier(variablesStore, prop, value, rule, ignoredImgSelectors, isCancelled) {\n    return variablesStore.getModifierForVariable({\n      varName: prop,\n      sourceValue: value,\n      rule,\n      ignoredImgSelectors,\n      isCancelled\n    });\n  }\n  function getVariableDependantModifier(variablesStore, prop, value) {\n    return variablesStore.getModifierForVarDependant(prop, value);\n  }\n  function cleanModificationCache() {\n    colorParseCache.clear();\n    clearColorModificationCache();\n    imageDetailsCache.clear();\n    cleanImageProcessingCache();\n    awaitingForImageLoading.clear();\n  }\n  const VAR_TYPE_BGCOLOR = 1 << 0;\n  const VAR_TYPE_TEXTCOLOR = 1 << 1;\n  const VAR_TYPE_BORDERCOLOR = 1 << 2;\n  const VAR_TYPE_BGIMG = 1 << 3;\n  class VariablesStore {\n    constructor() {\n      this.varTypes = new Map();\n      this.rulesQueue = [];\n      this.definedVars = new Set();\n      this.varRefs = new Map();\n      this.unknownColorVars = new Set();\n      this.unknownBgVars = new Set();\n      this.undefinedVars = new Set();\n      this.initialVarTypes = new Map();\n      this.changedTypeVars = new Set();\n      this.typeChangeSubscriptions = new Map();\n      this.unstableVarValues = new Map();\n    }\n    clear() {\n      this.varTypes.clear();\n      this.rulesQueue.splice(0);\n      this.definedVars.clear();\n      this.varRefs.clear();\n      this.unknownColorVars.clear();\n      this.unknownBgVars.clear();\n      this.undefinedVars.clear();\n      this.initialVarTypes.clear();\n      this.changedTypeVars.clear();\n      this.typeChangeSubscriptions.clear();\n      this.unstableVarValues.clear();\n    }\n    isVarType(varName, typeNum) {\n      return this.varTypes.has(varName) && (this.varTypes.get(varName) & typeNum) > 0;\n    }\n    addRulesForMatching(rules) {\n      this.rulesQueue.push(rules);\n    }\n    matchVariablesAndDependants() {\n      this.changedTypeVars.clear();\n      this.initialVarTypes = new Map(this.varTypes);\n      this.collectRootVariables();\n      this.collectVariablesAndVarDep(this.rulesQueue);\n      this.rulesQueue.splice(0);\n      this.collectRootVarDependants();\n      this.varRefs.forEach((refs, v) => {\n        refs.forEach(r => {\n          if (this.varTypes.has(v)) {\n            this.resolveVariableType(r, this.varTypes.get(v));\n          }\n        });\n      });\n      this.unknownColorVars.forEach(v => {\n        if (this.unknownBgVars.has(v)) {\n          this.unknownColorVars.delete(v);\n          this.unknownBgVars.delete(v);\n          this.resolveVariableType(v, VAR_TYPE_BGCOLOR);\n        } else if (this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR)) {\n          this.unknownColorVars.delete(v);\n        } else {\n          this.undefinedVars.add(v);\n        }\n      });\n      this.unknownBgVars.forEach(v => {\n        const hasColor = this.findVarRef(v, ref => {\n          return this.unknownColorVars.has(ref) || this.isVarType(ref, VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR);\n        }) != null;\n        if (hasColor) {\n          this.itarateVarRefs(v, ref => {\n            this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);\n          });\n        } else if (this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)) {\n          this.unknownBgVars.delete(v);\n        } else {\n          this.undefinedVars.add(v);\n        }\n      });\n      this.changedTypeVars.forEach(varName => {\n        if (this.typeChangeSubscriptions.has(varName)) {\n          this.typeChangeSubscriptions.get(varName).forEach(callback => {\n            callback();\n          });\n        }\n      });\n      this.changedTypeVars.clear();\n    }\n    getModifierForVariable(options) {\n      return theme => {\n        const {\n          varName,\n          sourceValue,\n          rule,\n          ignoredImgSelectors,\n          isCancelled\n        } = options;\n        const getDeclarations = () => {\n          const declarations = [];\n          const addModifiedValue = (typeNum, varNameWrapper, colorModifier) => {\n            if (!this.isVarType(varName, typeNum)) {\n              return;\n            }\n            const property = varNameWrapper(varName);\n            let modifiedValue;\n            if (isVarDependant(sourceValue)) {\n              if (isConstructedColorVar(sourceValue)) {\n                let value = insertVarValues(sourceValue, this.unstableVarValues);\n                if (!value) {\n                  value = typeNum === VAR_TYPE_BGCOLOR ? "#ffffff" : "#000000";\n                }\n                modifiedValue = colorModifier(value, theme);\n              } else {\n                modifiedValue = replaceCSSVariablesNames(sourceValue, v => varNameWrapper(v), fallback => colorModifier(fallback, theme));\n              }\n            } else {\n              modifiedValue = colorModifier(sourceValue, theme);\n            }\n            declarations.push({\n              property,\n              value: modifiedValue\n            });\n          };\n          addModifiedValue(VAR_TYPE_BGCOLOR, wrapBgColorVariableName, tryModifyBgColor);\n          addModifiedValue(VAR_TYPE_TEXTCOLOR, wrapTextColorVariableName, tryModifyTextColor);\n          addModifiedValue(VAR_TYPE_BORDERCOLOR, wrapBorderColorVariableName, tryModifyBorderColor);\n          if (this.isVarType(varName, VAR_TYPE_BGIMG)) {\n            const property = wrapBgImgVariableName(varName);\n            let modifiedValue = sourceValue;\n            if (isVarDependant(sourceValue)) {\n              modifiedValue = replaceCSSVariablesNames(sourceValue, v => wrapBgColorVariableName(v), fallback => tryModifyBgColor(fallback, theme));\n            }\n            const bgModifier = getBgImageModifier(modifiedValue, rule, ignoredImgSelectors, isCancelled);\n            modifiedValue = typeof bgModifier === "function" ? bgModifier(theme) : bgModifier;\n            declarations.push({\n              property,\n              value: modifiedValue\n            });\n          }\n          return declarations;\n        };\n        const callbacks = new Set();\n        const addListener = onTypeChange => {\n          const callback = () => {\n            const decs = getDeclarations();\n            onTypeChange(decs);\n          };\n          callbacks.add(callback);\n          this.subscribeForVarTypeChange(varName, callback);\n        };\n        const removeListeners = () => {\n          callbacks.forEach(callback => {\n            this.unsubscribeFromVariableTypeChanges(varName, callback);\n          });\n        };\n        return {\n          declarations: getDeclarations(),\n          onTypeChange: {\n            addListener,\n            removeListeners\n          }\n        };\n      };\n    }\n    getModifierForVarDependant(property, sourceValue) {\n      if (sourceValue.match(/^\\s*(rgb|hsl)a?\\(/)) {\n        const isBg = property.startsWith("background");\n        const isText = property === "color" || property === "caret-color";\n        return theme => {\n          let value = insertVarValues(sourceValue, this.unstableVarValues);\n          if (!value) {\n            value = isBg ? "#ffffff" : "#000000";\n          }\n          const modifier = isBg ? tryModifyBgColor : isText ? tryModifyTextColor : tryModifyBorderColor;\n          return modifier(value, theme);\n        };\n      }\n      if (property === "background-color") {\n        return theme => {\n          return replaceCSSVariablesNames(sourceValue, v => wrapBgColorVariableName(v), fallback => tryModifyBgColor(fallback, theme));\n        };\n      }\n      if (property === "color" || property === "caret-color") {\n        return theme => {\n          return replaceCSSVariablesNames(sourceValue, v => wrapTextColorVariableName(v), fallback => tryModifyTextColor(fallback, theme));\n        };\n      }\n      if (property === "background" || property === "background-image" || property === "box-shadow") {\n        return theme => {\n          const unknownVars = new Set();\n          const modify = () => {\n            const variableReplaced = replaceCSSVariablesNames(sourceValue, v => {\n              if (this.isVarType(v, VAR_TYPE_BGCOLOR)) {\n                return wrapBgColorVariableName(v);\n              }\n              if (this.isVarType(v, VAR_TYPE_BGIMG)) {\n                return wrapBgImgVariableName(v);\n              }\n              unknownVars.add(v);\n              return v;\n            }, fallback => tryModifyBgColor(fallback, theme));\n            if (property === "box-shadow") {\n              const shadowModifier = getShadowModifierWithInfo(variableReplaced);\n              const modifiedShadow = shadowModifier(theme);\n              if (modifiedShadow.unparseableMatchesLength !== modifiedShadow.matchesLength) {\n                return modifiedShadow.result;\n              }\n            }\n            return variableReplaced;\n          };\n          const modified = modify();\n          if (unknownVars.size > 0) {\n            return new Promise(resolve => {\n              const firstUnknownVar = unknownVars.values().next().value;\n              const callback = () => {\n                this.unsubscribeFromVariableTypeChanges(firstUnknownVar, callback);\n                const newValue = modify();\n                resolve(newValue);\n              };\n              this.subscribeForVarTypeChange(firstUnknownVar, callback);\n            });\n          }\n          return modified;\n        };\n      }\n      if (property.startsWith("border") || property.startsWith("outline")) {\n        if (sourceValue.endsWith(")")) {\n          const colorTypeMatch = sourceValue.match(/((rgb|hsl)a?)\\(/);\n          if (colorTypeMatch) {\n            const index = colorTypeMatch.index;\n            return theme => {\n              const value = insertVarValues(sourceValue, this.unstableVarValues);\n              if (!value) {\n                return sourceValue;\n              }\n              const beginning = sourceValue.substring(0, index);\n              const color = sourceValue.substring(index, sourceValue.length);\n              const inserted = insertVarValues(color, this.unstableVarValues);\n              const modified = tryModifyBorderColor(inserted, theme);\n              return `${beginning}${modified}`;\n            };\n          }\n        }\n        return theme => {\n          return replaceCSSVariablesNames(sourceValue, v => wrapBorderColorVariableName(v), fallback => tryModifyTextColor(fallback, theme));\n        };\n      }\n      return null;\n    }\n    subscribeForVarTypeChange(varName, callback) {\n      if (!this.typeChangeSubscriptions.has(varName)) {\n        this.typeChangeSubscriptions.set(varName, new Set());\n      }\n      const rootStore = this.typeChangeSubscriptions.get(varName);\n      if (!rootStore.has(callback)) {\n        rootStore.add(callback);\n      }\n    }\n    unsubscribeFromVariableTypeChanges(varName, callback) {\n      if (this.typeChangeSubscriptions.has(varName)) {\n        this.typeChangeSubscriptions.get(varName).delete(callback);\n      }\n    }\n    collectVariablesAndVarDep(ruleList) {\n      ruleList.forEach(rules => {\n        iterateCSSRules(rules, rule => {\n          rule.style && iterateCSSDeclarations(rule.style, (property, value) => {\n            if (isVariable(property)) {\n              this.inspectVariable(property, value);\n            }\n            if (isVarDependant(value)) {\n              this.inspectVarDependant(property, value);\n            }\n          });\n        });\n      });\n    }\n    collectRootVariables() {\n      iterateCSSDeclarations(document.documentElement.style, (property, value) => {\n        if (isVariable(property)) {\n          this.inspectVariable(property, value);\n        }\n      });\n    }\n    inspectVariable(varName, value) {\n      this.unstableVarValues.set(varName, value);\n      if (isVarDependant(value) && isConstructedColorVar(value)) {\n        this.unknownColorVars.add(varName);\n        this.definedVars.add(varName);\n      }\n      if (this.definedVars.has(varName)) {\n        return;\n      }\n      this.definedVars.add(varName);\n      const color = tryParseColor(value);\n      if (color) {\n        this.unknownColorVars.add(varName);\n      } else if (value.includes("url(") || value.includes("linear-gradient(") || value.includes("radial-gradient(")) {\n        this.resolveVariableType(varName, VAR_TYPE_BGIMG);\n      }\n    }\n    resolveVariableType(varName, typeNum) {\n      const initialType = this.initialVarTypes.get(varName) || 0;\n      const currentType = this.varTypes.get(varName) || 0;\n      const newType = currentType | typeNum;\n      this.varTypes.set(varName, newType);\n      if (newType !== initialType || this.undefinedVars.has(varName)) {\n        this.changedTypeVars.add(varName);\n        this.undefinedVars.delete(varName);\n      }\n      this.unknownColorVars.delete(varName);\n      this.unknownBgVars.delete(varName);\n    }\n    collectRootVarDependants() {\n      iterateCSSDeclarations(document.documentElement.style, (property, value) => {\n        if (isVarDependant(value)) {\n          this.inspectVarDependant(property, value);\n        }\n      });\n    }\n    inspectVarDependant(property, value) {\n      if (isVariable(property)) {\n        this.iterateVarDeps(value, ref => {\n          if (!this.varRefs.has(property)) {\n            this.varRefs.set(property, new Set());\n          }\n          this.varRefs.get(property).add(ref);\n        });\n      } else if (property === "background-color" || property === "box-shadow") {\n        this.iterateVarDeps(value, v => this.resolveVariableType(v, VAR_TYPE_BGCOLOR));\n      } else if (property === "color" || property === "caret-color") {\n        this.iterateVarDeps(value, v => this.resolveVariableType(v, VAR_TYPE_TEXTCOLOR));\n      } else if (property.startsWith("border") || property.startsWith("outline")) {\n        this.iterateVarDeps(value, v => this.resolveVariableType(v, VAR_TYPE_BORDERCOLOR));\n      } else if (property === "background" || property === "background-image") {\n        this.iterateVarDeps(value, v => {\n          if (this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)) {\n            return;\n          }\n          const isBgColor = this.findVarRef(v, ref => {\n            return this.unknownColorVars.has(ref) || this.isVarType(ref, VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR);\n          }) != null;\n          this.itarateVarRefs(v, ref => {\n            if (isBgColor) {\n              this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);\n            } else {\n              this.unknownBgVars.add(ref);\n            }\n          });\n        });\n      }\n    }\n    iterateVarDeps(value, iterator) {\n      const varDeps = new Set();\n      iterateVarDependencies(value, v => varDeps.add(v));\n      varDeps.forEach(v => iterator(v));\n    }\n    findVarRef(varName, iterator, stack = new Set()) {\n      if (stack.has(varName)) {\n        return null;\n      }\n      stack.add(varName);\n      const result = iterator(varName);\n      if (result) {\n        return varName;\n      }\n      const refs = this.varRefs.get(varName);\n      if (!refs || refs.size === 0) {\n        return null;\n      }\n      for (const ref of refs) {\n        const found = this.findVarRef(ref, iterator, stack);\n        if (found) {\n          return found;\n        }\n      }\n      return null;\n    }\n    itarateVarRefs(varName, iterator) {\n      this.findVarRef(varName, ref => {\n        iterator(ref);\n        return false;\n      });\n    }\n    setOnRootVariableChange(callback) {\n      this.onRootVariableDefined = callback;\n    }\n    putRootVars(styleElement, theme) {\n      const sheet = styleElement.sheet;\n      if (sheet.cssRules.length > 0) {\n        sheet.deleteRule(0);\n      }\n      const declarations = new Map();\n      iterateCSSDeclarations(document.documentElement.style, (property, value) => {\n        if (isVariable(property)) {\n          if (this.isVarType(property, VAR_TYPE_BGCOLOR)) {\n            declarations.set(wrapBgColorVariableName(property), tryModifyBgColor(value, theme));\n          }\n          if (this.isVarType(property, VAR_TYPE_TEXTCOLOR)) {\n            declarations.set(wrapTextColorVariableName(property), tryModifyTextColor(value, theme));\n          }\n          if (this.isVarType(property, VAR_TYPE_BORDERCOLOR)) {\n            declarations.set(wrapBorderColorVariableName(property), tryModifyBorderColor(value, theme));\n          }\n          this.subscribeForVarTypeChange(property, this.onRootVariableDefined);\n        }\n      });\n      const cssLines = [];\n      cssLines.push(":root {");\n      for (const [property, value] of declarations) {\n        cssLines.push(`    ${property}: ${value};`);\n      }\n      cssLines.push("}");\n      const cssText = cssLines.join("\\n");\n      sheet.insertRule(cssText);\n    }\n  }\n  const variablesStore = new VariablesStore();\n  function getVariableRange(input, searchStart = 0) {\n    const start = input.indexOf("var(", searchStart);\n    if (start >= 0) {\n      const range = getParenthesesRange(input, start + 3);\n      if (range) {\n        return {\n          start,\n          end: range.end\n        };\n      }\n      return null;\n    }\n  }\n  function getVariablesMatches(input) {\n    const ranges = [];\n    let i = 0;\n    let range;\n    while (range = getVariableRange(input, i)) {\n      const {\n        start,\n        end\n      } = range;\n      ranges.push({\n        start,\n        end,\n        value: input.substring(start, end)\n      });\n      i = range.end + 1;\n    }\n    return ranges;\n  }\n  function replaceVariablesMatches(input, replacer) {\n    const matches = getVariablesMatches(input);\n    const matchesCount = matches.length;\n    if (matchesCount === 0) {\n      return input;\n    }\n    const inputLength = input.length;\n    const replacements = matches.map(m => replacer(m.value));\n    const parts = [];\n    parts.push(input.substring(0, matches[0].start));\n    for (let i = 0; i < matchesCount; i++) {\n      parts.push(replacements[i]);\n      const start = matches[i].end;\n      const end = i < matchesCount - 1 ? matches[i + 1].start : inputLength;\n      parts.push(input.substring(start, end));\n    }\n    return parts.join("");\n  }\n  function getVariableNameAndFallback(match) {\n    const commaIndex = match.indexOf(",");\n    let name;\n    let fallback;\n    if (commaIndex >= 0) {\n      name = match.substring(4, commaIndex).trim();\n      fallback = match.substring(commaIndex + 1, match.length - 1).trim();\n    } else {\n      name = match.substring(4, match.length - 1).trim();\n      fallback = "";\n    }\n    return {\n      name,\n      fallback\n    };\n  }\n  function replaceCSSVariablesNames(value, nameReplacer, fallbackReplacer) {\n    const matchReplacer = match => {\n      const {\n        name,\n        fallback\n      } = getVariableNameAndFallback(match);\n      const newName = nameReplacer(name);\n      if (!fallback) {\n        return `var(${newName})`;\n      }\n      let newFallback;\n      if (isVarDependant(fallback)) {\n        newFallback = replaceCSSVariablesNames(fallback, nameReplacer, fallbackReplacer);\n      } else if (fallbackReplacer) {\n        newFallback = fallbackReplacer(fallback);\n      } else {\n        newFallback = fallback;\n      }\n      return `var(${newName}, ${newFallback})`;\n    };\n    return replaceVariablesMatches(value, matchReplacer);\n  }\n  function iterateVarDependencies(value, iterator) {\n    replaceCSSVariablesNames(value, varName => {\n      iterator(varName);\n      return varName;\n    });\n  }\n  function wrapBgColorVariableName(name) {\n    return `--darkreader-bg${name}`;\n  }\n  function wrapTextColorVariableName(name) {\n    return `--darkreader-text${name}`;\n  }\n  function wrapBorderColorVariableName(name) {\n    return `--darkreader-border${name}`;\n  }\n  function wrapBgImgVariableName(name) {\n    return `--darkreader-bgimg${name}`;\n  }\n  function isVariable(property) {\n    return property.startsWith("--");\n  }\n  function isVarDependant(value) {\n    return value.includes("var(");\n  }\n  function isConstructedColorVar(value) {\n    return value.match(/^\\s*(rgb|hsl)a?\\(/);\n  }\n  function tryModifyBgColor(color, theme) {\n    const rgb = tryParseColor(color);\n    return rgb ? modifyBackgroundColor(rgb, theme) : color;\n  }\n  function tryModifyTextColor(color, theme) {\n    const rgb = tryParseColor(color);\n    return rgb ? modifyForegroundColor(rgb, theme) : color;\n  }\n  function tryModifyBorderColor(color, theme) {\n    const rgb = tryParseColor(color);\n    return rgb ? modifyBorderColor(rgb, theme) : color;\n  }\n  function insertVarValues(source, varValues, stack = new Set()) {\n    let containsUnresolvedVar = false;\n    const matchReplacer = match => {\n      const {\n        name,\n        fallback\n      } = getVariableNameAndFallback(match);\n      if (stack.has(name)) {\n        containsUnresolvedVar = true;\n        return null;\n      }\n      stack.add(name);\n      const varValue = varValues.get(name) || fallback;\n      let inserted = null;\n      if (varValue) {\n        if (isVarDependant(varValue)) {\n          inserted = insertVarValues(varValue, varValues, stack);\n        } else {\n          inserted = varValue;\n        }\n      }\n      if (!inserted) {\n        containsUnresolvedVar = true;\n        return null;\n      }\n      return inserted;\n    };\n    const replaced = replaceVariablesMatches(source, matchReplacer);\n    if (containsUnresolvedVar) {\n      return null;\n    }\n    return replaced;\n  }\n  const overrides = {\n    "background-color": {\n      customProp: "--darkreader-inline-bgcolor",\n      cssProp: "background-color",\n      dataAttr: "data-darkreader-inline-bgcolor"\n    },\n    "background-image": {\n      customProp: "--darkreader-inline-bgimage",\n      cssProp: "background-image",\n      dataAttr: "data-darkreader-inline-bgimage"\n    },\n    "border-color": {\n      customProp: "--darkreader-inline-border",\n      cssProp: "border-color",\n      dataAttr: "data-darkreader-inline-border"\n    },\n    "border-bottom-color": {\n      customProp: "--darkreader-inline-border-bottom",\n      cssProp: "border-bottom-color",\n      dataAttr: "data-darkreader-inline-border-bottom"\n    },\n    "border-left-color": {\n      customProp: "--darkreader-inline-border-left",\n      cssProp: "border-left-color",\n      dataAttr: "data-darkreader-inline-border-left"\n    },\n    "border-right-color": {\n      customProp: "--darkreader-inline-border-right",\n      cssProp: "border-right-color",\n      dataAttr: "data-darkreader-inline-border-right"\n    },\n    "border-top-color": {\n      customProp: "--darkreader-inline-border-top",\n      cssProp: "border-top-color",\n      dataAttr: "data-darkreader-inline-border-top"\n    },\n    "box-shadow": {\n      customProp: "--darkreader-inline-boxshadow",\n      cssProp: "box-shadow",\n      dataAttr: "data-darkreader-inline-boxshadow"\n    },\n    "color": {\n      customProp: "--darkreader-inline-color",\n      cssProp: "color",\n      dataAttr: "data-darkreader-inline-color"\n    },\n    "fill": {\n      customProp: "--darkreader-inline-fill",\n      cssProp: "fill",\n      dataAttr: "data-darkreader-inline-fill"\n    },\n    "stroke": {\n      customProp: "--darkreader-inline-stroke",\n      cssProp: "stroke",\n      dataAttr: "data-darkreader-inline-stroke"\n    },\n    "outline-color": {\n      customProp: "--darkreader-inline-outline",\n      cssProp: "outline-color",\n      dataAttr: "data-darkreader-inline-outline"\n    },\n    "stop-color": {\n      customProp: "--darkreader-inline-stopcolor",\n      cssProp: "stop-color",\n      dataAttr: "data-darkreader-inline-stopcolor"\n    }\n  };\n  const overridesList = Object.values(overrides);\n  const normalizedPropList = {};\n  overridesList.forEach(({\n    cssProp,\n    customProp\n  }) => normalizedPropList[customProp] = cssProp);\n  const INLINE_STYLE_ATTRS = ["style", "fill", "stop-color", "stroke", "bgcolor", "color"];\n  const INLINE_STYLE_SELECTOR = INLINE_STYLE_ATTRS.map(attr => `[${attr}]`).join(", ");\n  function getInlineOverrideStyle() {\n    return overridesList.map(({\n      dataAttr,\n      customProp,\n      cssProp\n    }) => {\n      return [`[${dataAttr}] {`, `  ${cssProp}: var(${customProp}) !important;`, "}"].join("\\n");\n    }).join("\\n");\n  }\n  function getInlineStyleElements(root) {\n    const results = [];\n    if (root instanceof Element && root.matches(INLINE_STYLE_SELECTOR)) {\n      results.push(root);\n    }\n    if (root instanceof Element || isShadowDomSupported && root instanceof ShadowRoot || root instanceof Document) {\n      push(results, root.querySelectorAll(INLINE_STYLE_SELECTOR));\n    }\n    return results;\n  }\n  const treeObservers = new Map();\n  const attrObservers = new Map();\n  function watchForInlineStyles(elementStyleDidChange, shadowRootDiscovered) {\n    deepWatchForInlineStyles(document, elementStyleDidChange, shadowRootDiscovered);\n    iterateShadowHosts(document.documentElement, host => {\n      deepWatchForInlineStyles(host.shadowRoot, elementStyleDidChange, shadowRootDiscovered);\n    });\n  }\n  function deepWatchForInlineStyles(root, elementStyleDidChange, shadowRootDiscovered) {\n    if (treeObservers.has(root)) {\n      treeObservers.get(root).disconnect();\n      attrObservers.get(root).disconnect();\n    }\n    const discoveredNodes = new WeakSet();\n    function discoverNodes(node) {\n      getInlineStyleElements(node).forEach(el => {\n        if (discoveredNodes.has(el)) {\n          return;\n        }\n        discoveredNodes.add(el);\n        elementStyleDidChange(el);\n      });\n      iterateShadowHosts(node, n => {\n        if (discoveredNodes.has(node)) {\n          return;\n        }\n        discoveredNodes.add(node);\n        shadowRootDiscovered(n.shadowRoot);\n        deepWatchForInlineStyles(n.shadowRoot, elementStyleDidChange, shadowRootDiscovered);\n      });\n    }\n    const treeObserver = createOptimizedTreeObserver(root, {\n      onMinorMutations: ({\n        additions\n      }) => {\n        additions.forEach(added => discoverNodes(added));\n      },\n      onHugeMutations: () => {\n        discoverNodes(root);\n      }\n    });\n    treeObservers.set(root, treeObserver);\n    let attemptCount = 0;\n    let start = null;\n    const ATTEMPTS_INTERVAL = getDuration({\n      seconds: 10\n    });\n    const RETRY_TIMEOUT = getDuration({\n      seconds: 2\n    });\n    const MAX_ATTEMPTS_COUNT = 50;\n    let cache = [];\n    let timeoutId = null;\n    const handleAttributeMutations = throttle(mutations => {\n      mutations.forEach(m => {\n        if (INLINE_STYLE_ATTRS.includes(m.attributeName)) {\n          elementStyleDidChange(m.target);\n        }\n      });\n    });\n    const attrObserver = new MutationObserver(mutations => {\n      if (timeoutId) {\n        cache.push(...mutations);\n        return;\n      }\n      attemptCount++;\n      const now = Date.now();\n      if (start == null) {\n        start = now;\n      } else if (attemptCount >= MAX_ATTEMPTS_COUNT) {\n        if (now - start < ATTEMPTS_INTERVAL) {\n          timeoutId = setTimeout(() => {\n            start = null;\n            attemptCount = 0;\n            timeoutId = null;\n            const attributeCache = cache;\n            cache = [];\n            handleAttributeMutations(attributeCache);\n          }, RETRY_TIMEOUT);\n          cache.push(...mutations);\n          return;\n        }\n        start = now;\n        attemptCount = 1;\n      }\n      handleAttributeMutations(mutations);\n    });\n    attrObserver.observe(root, {\n      attributes: true,\n      attributeFilter: INLINE_STYLE_ATTRS.concat(overridesList.map(({\n        dataAttr\n      }) => dataAttr)),\n      subtree: true\n    });\n    attrObservers.set(root, attrObserver);\n  }\n  function stopWatchingForInlineStyles() {\n    treeObservers.forEach(o => o.disconnect());\n    attrObservers.forEach(o => o.disconnect());\n    treeObservers.clear();\n    attrObservers.clear();\n  }\n  const inlineStyleCache = new WeakMap();\n  const filterProps = ["brightness", "contrast", "grayscale", "sepia", "mode"];\n  function getInlineStyleCacheKey(el, theme) {\n    return INLINE_STYLE_ATTRS.map(attr => `${attr}="${el.getAttribute(attr)}"`).concat(filterProps.map(prop => `${prop}="${theme[prop]}"`)).join(" ");\n  }\n  function shouldIgnoreInlineStyle(element, selectors) {\n    for (let i = 0, len = selectors.length; i < len; i++) {\n      const ingnoredSelector = selectors[i];\n      if (element.matches(ingnoredSelector)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function overrideInlineStyle(element, theme, ignoreInlineSelectors, ignoreImageSelectors) {\n    const cacheKey = getInlineStyleCacheKey(element, theme);\n    if (cacheKey === inlineStyleCache.get(element)) {\n      return;\n    }\n    const unsetProps = new Set(Object.keys(overrides));\n    function setCustomProp(targetCSSProp, modifierCSSProp, cssVal) {\n      const {\n        customProp,\n        dataAttr\n      } = overrides[targetCSSProp];\n      const mod = getModifiableCSSDeclaration(modifierCSSProp, cssVal, {}, variablesStore, ignoreImageSelectors, null);\n      if (!mod) {\n        return;\n      }\n      let value = mod.value;\n      if (typeof value === "function") {\n        value = value(theme);\n      }\n      element.style.setProperty(customProp, value);\n      if (!element.hasAttribute(dataAttr)) {\n        element.setAttribute(dataAttr, "");\n      }\n      unsetProps.delete(targetCSSProp);\n    }\n    if (ignoreInlineSelectors.length > 0) {\n      if (shouldIgnoreInlineStyle(element, ignoreInlineSelectors)) {\n        unsetProps.forEach(cssProp => {\n          element.removeAttribute(overrides[cssProp].dataAttr);\n        });\n        return;\n      }\n    }\n    if (element.hasAttribute("bgcolor")) {\n      let value = element.getAttribute("bgcolor");\n      if (value.match(/^[0-9a-f]{3}$/i) || value.match(/^[0-9a-f]{6}$/i)) {\n        value = `#${value}`;\n      }\n      setCustomProp("background-color", "background-color", value);\n    }\n    if (element.hasAttribute("color") && element.rel !== "mask-icon") {\n      let value = element.getAttribute("color");\n      if (value.match(/^[0-9a-f]{3}$/i) || value.match(/^[0-9a-f]{6}$/i)) {\n        value = `#${value}`;\n      }\n      setCustomProp("color", "color", value);\n    }\n    if (element instanceof SVGElement) {\n      if (element.hasAttribute("fill")) {\n        const SMALL_SVG_LIMIT = 32;\n        const value = element.getAttribute("fill");\n        if (value !== "none") {\n          if (!(element instanceof SVGTextElement)) {\n            const handleSVGElement = () => {\n              const {\n                width,\n                height\n              } = element.getBoundingClientRect();\n              const isBg = width > SMALL_SVG_LIMIT || height > SMALL_SVG_LIMIT;\n              setCustomProp("fill", isBg ? "background-color" : "color", value);\n            };\n            if (isReadyStateComplete()) {\n              handleSVGElement();\n            } else {\n              addReadyStateCompleteListener(handleSVGElement);\n            }\n          } else {\n            setCustomProp("fill", "color", value);\n          }\n        }\n      }\n      if (element.hasAttribute("stop-color")) {\n        setCustomProp("stop-color", "background-color", element.getAttribute("stop-color"));\n      }\n    }\n    if (element.hasAttribute("stroke")) {\n      const value = element.getAttribute("stroke");\n      setCustomProp("stroke", element instanceof SVGLineElement || element instanceof SVGTextElement ? "border-color" : "color", value);\n    }\n    element.style && iterateCSSDeclarations(element.style, (property, value) => {\n      if (property === "background-image" && value.includes("url")) {\n        return;\n      }\n      if (overrides.hasOwnProperty(property)) {\n        setCustomProp(property, property, value);\n      } else {\n        const overridenProp = normalizedPropList[property];\n        if (overridenProp && !element.style.getPropertyValue(overridenProp) && !element.hasAttribute(overridenProp)) {\n          if (overridenProp === "background-color" && element.hasAttribute("bgcolor")) {\n            return;\n          }\n          element.style.setProperty(property, "");\n        }\n      }\n    });\n    if (element.style && element instanceof SVGTextElement && element.style.fill) {\n      setCustomProp("fill", "color", element.style.getPropertyValue("fill"));\n    }\n    forEach(unsetProps, cssProp => {\n      element.removeAttribute(overrides[cssProp].dataAttr);\n    });\n    inlineStyleCache.set(element, getInlineStyleCacheKey(element, theme));\n  }\n  const metaThemeColorName = "theme-color";\n  const metaThemeColorSelector = `meta[name="${metaThemeColorName}"]`;\n  let srcMetaThemeColor = null;\n  let observer = null;\n  function changeMetaThemeColor(meta, theme) {\n    srcMetaThemeColor = srcMetaThemeColor || meta.content;\n    try {\n      const color = parse(srcMetaThemeColor);\n      meta.content = modifyBackgroundColor(color, theme);\n    } catch (err) {}\n  }\n  function changeMetaThemeColorWhenAvailable(theme) {\n    const meta = document.querySelector(metaThemeColorSelector);\n    if (meta) {\n      changeMetaThemeColor(meta, theme);\n    } else {\n      if (observer) {\n        observer.disconnect();\n      }\n      observer = new MutationObserver(mutations => {\n        loop: for (let i = 0; i < mutations.length; i++) {\n          const {\n            addedNodes\n          } = mutations[i];\n          for (let j = 0; j < addedNodes.length; j++) {\n            const node = addedNodes[j];\n            if (node instanceof HTMLMetaElement && node.name === metaThemeColorName) {\n              observer.disconnect();\n              observer = null;\n              changeMetaThemeColor(node, theme);\n              break loop;\n            }\n          }\n        }\n      });\n      observer.observe(document.head, {\n        childList: true\n      });\n    }\n  }\n  function restoreMetaThemeColor() {\n    if (observer) {\n      observer.disconnect();\n      observer = null;\n    }\n    const meta = document.querySelector(metaThemeColorSelector);\n    if (meta && srcMetaThemeColor) {\n      meta.content = srcMetaThemeColor;\n    }\n  }\n  const themeCacheKeys = ["mode", "brightness", "contrast", "grayscale", "sepia", "darkSchemeBackgroundColor", "darkSchemeTextColor", "lightSchemeBackgroundColor", "lightSchemeTextColor"];\n  function getThemeKey(theme) {\n    return themeCacheKeys.map(p => `${p}:${theme[p]}`).join(";");\n  }\n  const asyncQueue = createAsyncTasksQueue();\n  function createStyleSheetModifier() {\n    let renderId = 0;\n    const rulesTextCache = new Set();\n    const rulesModCache = new Map();\n    const varTypeChangeCleaners = new Set();\n    let prevFilterKey = null;\n    let hasNonLoadedLink = false;\n    let wasRebuilt = false;\n    function shouldRebuildStyle() {\n      return hasNonLoadedLink && !wasRebuilt;\n    }\n    function modifySheet(options) {\n      const rules = options.sourceCSSRules;\n      const {\n        theme,\n        ignoreImageAnalysis,\n        force,\n        prepareSheet,\n        isAsyncCancelled\n      } = options;\n      let rulesChanged = rulesModCache.size === 0;\n      const notFoundCacheKeys = new Set(rulesModCache.keys());\n      const themeKey = getThemeKey(theme);\n      const themeChanged = themeKey !== prevFilterKey;\n      if (hasNonLoadedLink) {\n        wasRebuilt = true;\n      }\n      const modRules = [];\n      iterateCSSRules(rules, rule => {\n        let cssText = rule.cssText;\n        let textDiffersFromPrev = false;\n        notFoundCacheKeys.delete(cssText);\n        if (rule.parentRule instanceof CSSMediaRule) {\n          cssText += `;${rule.parentRule.media.mediaText}`;\n        }\n        if (!rulesTextCache.has(cssText)) {\n          rulesTextCache.add(cssText);\n          textDiffersFromPrev = true;\n        }\n        if (textDiffersFromPrev) {\n          rulesChanged = true;\n        } else {\n          modRules.push(rulesModCache.get(cssText));\n          return;\n        }\n        const modDecs = [];\n        rule.style && iterateCSSDeclarations(rule.style, (property, value) => {\n          const mod = getModifiableCSSDeclaration(property, value, rule, variablesStore, ignoreImageAnalysis, isAsyncCancelled);\n          if (mod) {\n            modDecs.push(mod);\n          }\n        });\n        let modRule = null;\n        if (modDecs.length > 0) {\n          const parentRule = rule.parentRule;\n          modRule = {\n            selector: rule.selectorText,\n            declarations: modDecs,\n            parentRule\n          };\n          modRules.push(modRule);\n        }\n        rulesModCache.set(cssText, modRule);\n      }, () => {\n        hasNonLoadedLink = true;\n      });\n      notFoundCacheKeys.forEach(key => {\n        rulesTextCache.delete(key);\n        rulesModCache.delete(key);\n      });\n      prevFilterKey = themeKey;\n      if (!force && !rulesChanged && !themeChanged) {\n        return;\n      }\n      renderId++;\n      function setRule(target, index, rule) {\n        // console.log("target=",target,",rule=",rule,",index=",index);\n        const {\n          selector,\n          declarations\n        } = rule;\n        const getDeclarationText = dec => {\n          const {\n            property,\n            value,\n            important,\n            sourceValue\n          } = dec;\n          return `${property}: ${value == null ? sourceValue : value}${important ? " !important" : ""};`;\n        };\n        const ruleText = `${selector} { ${declarations.map(getDeclarationText).join(" ")} }`;\n        // console.log("target=",target,",ruleText=",ruleText,",index=",index);\n        target.insertRule(ruleText, index);\n      }\n      const asyncDeclarations = new Map();\n      const varDeclarations = new Map();\n      let asyncDeclarationCounter = 0;\n      let varDeclarationCounter = 0;\n      const rootReadyGroup = {\n        rule: null,\n        rules: [],\n        isGroup: true\n      };\n      const groupRefs = new WeakMap();\n      function getGroup(rule) {\n        if (rule == null) {\n          return rootReadyGroup;\n        }\n        if (groupRefs.has(rule)) {\n          return groupRefs.get(rule);\n        }\n        const group = {\n          rule,\n          rules: [],\n          isGroup: true\n        };\n        groupRefs.set(rule, group);\n        const parentGroup = getGroup(rule.parentRule);\n        parentGroup.rules.push(group);\n        return group;\n      }\n      varTypeChangeCleaners.forEach(clear => clear());\n      varTypeChangeCleaners.clear();\n      modRules.filter(r => r).forEach(({\n        selector,\n        declarations,\n        parentRule\n      }) => {\n        const group = getGroup(parentRule);\n        const readyStyleRule = {\n          selector,\n          declarations: [],\n          isGroup: false\n        };\n        const readyDeclarations = readyStyleRule.declarations;\n        group.rules.push(readyStyleRule);\n        function handleAsyncDeclaration(property, modified, important, sourceValue) {\n          const asyncKey = ++asyncDeclarationCounter;\n          const asyncDeclaration = {\n            property,\n            value: null,\n            important,\n            asyncKey,\n            sourceValue\n          };\n          readyDeclarations.push(asyncDeclaration);\n          const currentRenderId = renderId;\n          modified.then(asyncValue => {\n            if (!asyncValue || isAsyncCancelled() || currentRenderId !== renderId) {\n              return;\n            }\n            asyncDeclaration.value = asyncValue;\n            asyncQueue.add(() => {\n              if (isAsyncCancelled() || currentRenderId !== renderId) {\n                return;\n              }\n              rebuildAsyncRule(asyncKey);\n            });\n          });\n        }\n        function handleVarDeclarations(property, modified, important, sourceValue) {\n          const {\n            declarations: varDecs,\n            onTypeChange\n          } = modified;\n          const varKey = ++varDeclarationCounter;\n          const currentRenderId = renderId;\n          const initialIndex = readyDeclarations.length;\n          let oldDecs = [];\n          if (varDecs.length === 0) {\n            const tempDec = {\n              property,\n              value: sourceValue,\n              important,\n              sourceValue,\n              varKey\n            };\n            readyDeclarations.push(tempDec);\n            oldDecs = [tempDec];\n          }\n          varDecs.forEach(mod => {\n            if (mod.value instanceof Promise) {\n              handleAsyncDeclaration(mod.property, mod.value, important, sourceValue);\n            } else {\n              const readyDec = {\n                property: mod.property,\n                value: mod.value,\n                important,\n                sourceValue,\n                varKey\n              };\n              readyDeclarations.push(readyDec);\n              oldDecs.push(readyDec);\n            }\n          });\n          onTypeChange.addListener(newDecs => {\n            if (isAsyncCancelled() || currentRenderId !== renderId) {\n              return;\n            }\n            const readyVarDecs = newDecs.map(mod => {\n              return {\n                property: mod.property,\n                value: mod.value,\n                important,\n                sourceValue,\n                varKey\n              };\n            });\n            const index = readyDeclarations.indexOf(oldDecs[0], initialIndex);\n            readyDeclarations.splice(index, oldDecs.length, ...readyVarDecs);\n            oldDecs = readyVarDecs;\n            rebuildVarRule(varKey);\n          });\n          varTypeChangeCleaners.add(() => onTypeChange.removeListeners());\n        }\n        declarations.forEach(({\n          property,\n          value,\n          important,\n          sourceValue\n        }) => {\n          if (typeof value === "function") {\n            const modified = value(theme);\n            if (modified instanceof Promise) {\n              handleAsyncDeclaration(property, modified, important, sourceValue);\n            } else if (property.startsWith("--")) {\n              handleVarDeclarations(property, modified, important, sourceValue);\n            } else {\n              readyDeclarations.push({\n                property,\n                value: modified,\n                important,\n                sourceValue\n              });\n            }\n          } else {\n            readyDeclarations.push({\n              property,\n              value,\n              important,\n              sourceValue\n            });\n          }\n        });\n      });\n      const sheet = prepareSheet();\n      function buildStyleSheet() {\n        function createTarget(group, parent) {\n          const {\n            rule\n          } = group;\n          if (rule instanceof CSSMediaRule) {\n            const {\n              media\n            } = rule;\n            const index = parent.cssRules.length;\n            parent.insertRule(`@media ${media.mediaText} {}`, index);\n            return parent.cssRules[index];\n          }\n          return parent;\n        }\n        function iterateReadyRules(group, target, styleIterator) {\n          group.rules.forEach(r => {\n            if (r.isGroup) {\n              const t = createTarget(r, target);\n              iterateReadyRules(r, t, styleIterator);\n            } else {\n              styleIterator(r, target);\n            }\n          });\n        }\n        iterateReadyRules(rootReadyGroup, sheet, (rule, target) => {\n          const index = target.cssRules.length;\n          rule.declarations.forEach(({\n            asyncKey,\n            varKey\n          }) => {\n            if (asyncKey != null) {\n              asyncDeclarations.set(asyncKey, {\n                rule,\n                target,\n                index\n              });\n            }\n            if (varKey != null) {\n              varDeclarations.set(varKey, {\n                rule,\n                target,\n                index\n              });\n            }\n          });\n          setRule(target, index, rule);\n        });\n      }\n      function rebuildAsyncRule(key) {\n        // console.log("key====",key,",asyncDeclarations====",asyncDeclarations);\n        if (varDeclarations && varDeclarations.get(key) && typeof varDeclarations.get(key) !== "undefined") {\n          const {\n            rule,\n            target,\n            index\n          } = asyncDeclarations.get(key);\n          target.deleteRule(index);\n          setRule(target, index, rule);\n          asyncDeclarations.delete(key);\n        }\n      }\n      function rebuildVarRule(key) {\n        if (varDeclarations && varDeclarations.get(key) && typeof varDeclarations.get(key) !== "undefined") {\n          const {\n            rule,\n            target,\n            index\n          } = varDeclarations.get(key);\n          target.deleteRule(index);\n          setRule(target, index, rule);\n        }\n      }\n      buildStyleSheet();\n    }\n    return {\n      modifySheet,\n      shouldRebuildStyle\n    };\n  }\n  const STYLE_SELECTOR = \'style, link[rel*="stylesheet" i]:not([disabled])\';\n  function shouldManageStyle(element) {\n    return (element instanceof HTMLStyleElement || element instanceof SVGStyleElement || element instanceof HTMLLinkElement && element.rel && element.rel.toLowerCase().includes("stylesheet") && !element.disabled) && !element.classList.contains("darkreader") && element.media.toLowerCase() !== "print" && !element.classList.contains("stylus");\n  }\n  function getManageableStyles(node, results = [], deep = true) {\n    if (shouldManageStyle(node)) {\n      results.push(node);\n    } else if (node instanceof Element || isShadowDomSupported && node instanceof ShadowRoot || node === document) {\n      forEach(node.querySelectorAll(STYLE_SELECTOR), style => getManageableStyles(style, results, false));\n      if (deep) {\n        iterateShadowHosts(node, host => getManageableStyles(host.shadowRoot, results, false));\n      }\n    }\n    return results;\n  }\n  const syncStyleSet = new WeakSet();\n  const corsStyleSet = new WeakSet();\n  let canOptimizeUsingProxy$1 = false;\n  document.addEventListener("__darkreader__inlineScriptsAllowed", () => {\n    canOptimizeUsingProxy$1 = true;\n  });\n  let loadingLinkCounter = 0;\n  const rejectorsForLoadingLinks = new Map();\n  function cleanLoadingLinks() {\n    rejectorsForLoadingLinks.clear();\n  }\n  function manageStyle(element, {\n    update,\n    loadingStart,\n    loadingEnd\n  }) {\n    const prevStyles = [];\n    let next = element;\n    while ((next = next.nextElementSibling) && next.matches(".darkreader")) {\n      prevStyles.push(next);\n    }\n    let corsCopy = prevStyles.find(el => el.matches(".darkreader--cors") && !corsStyleSet.has(el)) || null;\n    let syncStyle = prevStyles.find(el => el.matches(".darkreader--sync") && !syncStyleSet.has(el)) || null;\n    let corsCopyPositionWatcher = null;\n    let syncStylePositionWatcher = null;\n    let cancelAsyncOperations = false;\n    let isOverrideEmpty = true;\n    const sheetModifier = createStyleSheetModifier();\n    const observer = new MutationObserver(() => {\n      update();\n    });\n    const observerOptions = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    function containsCSSImport() {\n      return element instanceof HTMLStyleElement && element.textContent.trim().match(cssImportRegex);\n    }\n    function hasImports(cssRules, checkCrossOrigin) {\n      let result = false;\n      if (cssRules) {\n        let rule;\n        cssRulesLoop: for (let i = 0, len = cssRules.length; i < len; i++) {\n          rule = cssRules[i];\n          if (rule.href) {\n            if (checkCrossOrigin) {\n              if (rule.href.startsWith("http") && !rule.href.startsWith(location.origin)) {\n                result = true;\n                break cssRulesLoop;\n              }\n            } else {\n              result = true;\n              break cssRulesLoop;\n            }\n          }\n        }\n      }\n      return result;\n    }\n    function getRulesSync() {\n      if (corsCopy) {\n        return corsCopy.sheet.cssRules;\n      }\n      if (containsCSSImport()) {\n        return null;\n      }\n      const cssRules = safeGetSheetRules();\n      if (element instanceof HTMLLinkElement && !isRelativeHrefOnAbsolutePath(element.href) && hasImports(cssRules, false)) {\n        return null;\n      }\n      if (hasImports(cssRules, true)) {\n        return null;\n      }\n      return cssRules;\n    }\n    function insertStyle() {\n      if (corsCopy) {\n        if (element.nextSibling !== corsCopy) {\n          element.parentNode.insertBefore(corsCopy, element.nextSibling);\n        }\n        if (corsCopy.nextSibling !== syncStyle) {\n          element.parentNode.insertBefore(syncStyle, corsCopy.nextSibling);\n        }\n      } else if (element.nextSibling !== syncStyle) {\n        element.parentNode.insertBefore(syncStyle, element.nextSibling);\n      }\n    }\n    function createSyncStyle() {\n      syncStyle = element instanceof SVGStyleElement ? document.createElementNS("http://www.w3.org/2000/svg", "style") : document.createElement("style");\n      syncStyle.classList.add("darkreader");\n      syncStyle.classList.add("darkreader--sync");\n      syncStyle.media = "screen";\n      if (element.title) {\n        syncStyle.title = element.title;\n      }\n      syncStyleSet.add(syncStyle);\n    }\n    let isLoadingRules = false;\n    let wasLoadingError = false;\n    const loadingLinkId = ++loadingLinkCounter;\n    async function getRulesAsync() {\n      let cssText;\n      let cssBasePath;\n      if (element instanceof HTMLLinkElement) {\n        let [cssRules, accessError] = getRulesOrError();\n        if (!cssRules && !accessError && !isSafari || isSafari && !element.sheet || isStillLoadingError(accessError)) {\n          try {\n            logInfo(`Linkelement ${loadingLinkId} is not loaded yet and thus will be await for`, element);\n            await linkLoading(element, loadingLinkId);\n          } catch (err) {\n            wasLoadingError = true;\n          }\n          if (cancelAsyncOperations) {\n            return null;\n          }\n          [cssRules, accessError] = getRulesOrError();\n        }\n        if (cssRules) {\n          if (isRelativeHrefOnAbsolutePath(element.href)) {\n            return cssRules;\n          } else if (!hasImports(cssRules, false)) {\n            return cssRules;\n          }\n        }\n        cssText = await loadText(element.href);\n        cssBasePath = getCSSBaseBath(element.href);\n        if (cancelAsyncOperations) {\n          return null;\n        }\n      } else if (containsCSSImport()) {\n        cssText = element.textContent.trim();\n        cssBasePath = getCSSBaseBath(location.href);\n      } else {\n        return null;\n      }\n      if (cssText) {\n        try {\n          const fullCSSText = await replaceCSSImports(cssText, cssBasePath);\n          corsCopy = createCORSCopy(element, fullCSSText);\n        } catch (err) {}\n        if (corsCopy) {\n          corsCopyPositionWatcher = watchForNodePosition(corsCopy, "prev-sibling");\n          return corsCopy.sheet.cssRules;\n        }\n      }\n      return null;\n    }\n    function details() {\n      const rules = getRulesSync();\n      if (!rules) {\n        if (isLoadingRules || wasLoadingError) {\n          return null;\n        }\n        isLoadingRules = true;\n        loadingStart();\n        getRulesAsync().then(results => {\n          isLoadingRules = false;\n          loadingEnd();\n          if (results) {\n            update();\n          }\n        }).catch(err => {\n          isLoadingRules = false;\n          loadingEnd();\n        });\n        return null;\n      }\n      return {\n        rules\n      };\n    }\n    let forceRenderStyle = false;\n    function render(theme, ignoreImageAnalysis) {\n      const rules = getRulesSync();\n      if (!rules) {\n        return;\n      }\n      cancelAsyncOperations = false;\n      function removeCSSRulesFromSheet(sheet) {\n        try {\n          if (sheet.replaceSync) {\n            sheet.replaceSync("");\n            return;\n          }\n        } catch (err) {}\n        for (let i = sheet.cssRules.length - 1; i >= 0; i--) {\n          sheet.deleteRule(i);\n        }\n      }\n      function prepareOverridesSheet() {\n        if (!syncStyle) {\n          createSyncStyle();\n        }\n        syncStylePositionWatcher && syncStylePositionWatcher.stop();\n        insertStyle();\n        if (syncStyle.sheet == null) {\n          syncStyle.textContent = "";\n        }\n        const sheet = syncStyle.sheet;\n        removeCSSRulesFromSheet(sheet);\n        if (syncStylePositionWatcher) {\n          syncStylePositionWatcher.run();\n        } else {\n          syncStylePositionWatcher = watchForNodePosition(syncStyle, "prev-sibling", () => {\n            forceRenderStyle = true;\n            buildOverrides();\n          });\n        }\n        return syncStyle.sheet;\n      }\n      function buildOverrides() {\n        const force = forceRenderStyle;\n        forceRenderStyle = false;\n        sheetModifier.modifySheet({\n          prepareSheet: prepareOverridesSheet,\n          sourceCSSRules: rules,\n          theme,\n          ignoreImageAnalysis,\n          force,\n          isAsyncCancelled: () => cancelAsyncOperations\n        });\n        isOverrideEmpty = syncStyle.sheet.cssRules.length === 0;\n        if (sheetModifier.shouldRebuildStyle()) {\n          addReadyStateCompleteListener(() => update());\n        }\n      }\n      buildOverrides();\n    }\n    function getRulesOrError() {\n      try {\n        if (element.sheet == null) {\n          return [null, null];\n        }\n        return [element.sheet.cssRules, null];\n      } catch (err) {\n        return [null, err];\n      }\n    }\n    function isStillLoadingError(error) {\n      return error && error.message && error.message.includes("loading");\n    }\n    function safeGetSheetRules() {\n      const [cssRules, err] = getRulesOrError();\n      if (err) {\n        return null;\n      }\n      return cssRules;\n    }\n    function watchForSheetChanges() {\n      watchForSheetChangesUsingProxy();\n      if (!isThunderbird && !(canOptimizeUsingProxy$1 && element.sheet)) {\n        watchForSheetChangesUsingRAF();\n      }\n    }\n    let rulesChangeKey = null;\n    let rulesCheckFrameId = null;\n    function getRulesChangeKey() {\n      const rules = safeGetSheetRules();\n      return rules ? rules.length : null;\n    }\n    function didRulesKeyChange() {\n      return getRulesChangeKey() !== rulesChangeKey;\n    }\n    function watchForSheetChangesUsingRAF() {\n      rulesChangeKey = getRulesChangeKey();\n      stopWatchingForSheetChangesUsingRAF();\n      const checkForUpdate = () => {\n        if (didRulesKeyChange()) {\n          rulesChangeKey = getRulesChangeKey();\n          update();\n        }\n        if (canOptimizeUsingProxy$1 && element.sheet) {\n          stopWatchingForSheetChangesUsingRAF();\n          return;\n        }\n        rulesCheckFrameId = requestAnimationFrame(checkForUpdate);\n      };\n      checkForUpdate();\n    }\n    function stopWatchingForSheetChangesUsingRAF() {\n      cancelAnimationFrame(rulesCheckFrameId);\n    }\n    let areSheetChangesPending = false;\n    function onSheetChange() {\n      canOptimizeUsingProxy$1 = true;\n      stopWatchingForSheetChangesUsingRAF();\n      if (areSheetChangesPending) {\n        return;\n      }\n      function handleSheetChanges() {\n        areSheetChangesPending = false;\n        if (cancelAsyncOperations) {\n          return;\n        }\n        update();\n      }\n      areSheetChangesPending = true;\n      if (typeof queueMicrotask === "function") {\n        queueMicrotask(handleSheetChanges);\n      } else {\n        requestAnimationFrame(handleSheetChanges);\n      }\n    }\n    function watchForSheetChangesUsingProxy() {\n      element.addEventListener("__darkreader__updateSheet", onSheetChange);\n    }\n    function stopWatchingForSheetChangesUsingProxy() {\n      element.removeEventListener("__darkreader__updateSheet", onSheetChange);\n    }\n    function stopWatchingForSheetChanges() {\n      stopWatchingForSheetChangesUsingProxy();\n      stopWatchingForSheetChangesUsingRAF();\n    }\n    function pause() {\n      observer.disconnect();\n      cancelAsyncOperations = true;\n      corsCopyPositionWatcher && corsCopyPositionWatcher.stop();\n      syncStylePositionWatcher && syncStylePositionWatcher.stop();\n      stopWatchingForSheetChanges();\n    }\n    function destroy() {\n      pause();\n      removeNode(corsCopy);\n      removeNode(syncStyle);\n      loadingEnd();\n      if (rejectorsForLoadingLinks.has(loadingLinkId)) {\n        const reject = rejectorsForLoadingLinks.get(loadingLinkId);\n        rejectorsForLoadingLinks.delete(loadingLinkId);\n        reject && reject();\n      }\n    }\n    function watch() {\n      observer.observe(element, observerOptions);\n      if (element instanceof HTMLStyleElement) {\n        watchForSheetChanges();\n      }\n    }\n    const maxMoveCount = 10;\n    let moveCount = 0;\n    function restore() {\n      if (!syncStyle) {\n        return;\n      }\n      moveCount++;\n      if (moveCount > maxMoveCount) {\n        return;\n      }\n      insertStyle();\n      corsCopyPositionWatcher && corsCopyPositionWatcher.skip();\n      syncStylePositionWatcher && syncStylePositionWatcher.skip();\n      if (!isOverrideEmpty) {\n        forceRenderStyle = true;\n        update();\n      }\n    }\n    return {\n      details,\n      render,\n      pause,\n      destroy,\n      watch,\n      restore\n    };\n  }\n  async function linkLoading(link, loadingId) {\n    return new Promise((resolve, reject) => {\n      const cleanUp = () => {\n        link.removeEventListener("load", onLoad);\n        link.removeEventListener("error", onError);\n        rejectorsForLoadingLinks.delete(loadingId);\n      };\n      const onLoad = () => {\n        cleanUp();\n        resolve();\n      };\n      const onError = () => {\n        cleanUp();\n        reject(`Linkelement ${loadingId} couldn\'t be loaded. ${link.href}`);\n      };\n      rejectorsForLoadingLinks.set(loadingId, () => {\n        cleanUp();\n        reject();\n      });\n      link.addEventListener("load", onLoad);\n      link.addEventListener("error", onError);\n      if (!link.href) {\n        onError();\n      }\n    });\n  }\n  function getCSSImportURL(importDeclaration) {\n    return getCSSURLValue(importDeclaration.substring(7).trim().replace(/;$/, ""));\n  }\n  async function loadText(url) {\n    if (url.startsWith("data:")) {\n      return await (await fetch(url)).text();\n    }\n    return await bgFetch({\n      url,\n      responseType: "text",\n      mimeType: "text/css",\n      origin: window.location.origin\n    });\n  }\n  async function replaceCSSImports(cssText, basePath, cache = new Map()) {\n    cssText = removeCSSComments(cssText);\n    cssText = replaceCSSFontFace(cssText);\n    cssText = replaceCSSRelativeURLsWithAbsolute(cssText, basePath);\n    const importMatches = getMatches(cssImportRegex, cssText);\n    for (const match of importMatches) {\n      const importURL = getCSSImportURL(match);\n      const absoluteURL = getAbsoluteURL(basePath, importURL);\n      let importedCSS;\n      if (cache.has(absoluteURL)) {\n        importedCSS = cache.get(absoluteURL);\n      } else {\n        try {\n          importedCSS = await loadText(absoluteURL);\n          cache.set(absoluteURL, importedCSS);\n          importedCSS = await replaceCSSImports(importedCSS, getCSSBaseBath(absoluteURL), cache);\n        } catch (err) {\n          importedCSS = "";\n        }\n      }\n      cssText = cssText.split(match).join(importedCSS);\n    }\n    cssText = cssText.trim();\n    return cssText;\n  }\n  function createCORSCopy(srcElement, cssText) {\n    if (!cssText) {\n      return null;\n    }\n    const cors = document.createElement("style");\n    cors.classList.add("darkreader");\n    cors.classList.add("darkreader--cors");\n    cors.media = "screen";\n    cors.textContent = cssText;\n    srcElement.parentNode.insertBefore(cors, srcElement.nextSibling);\n    cors.sheet.disabled = true;\n    corsStyleSet.add(cors);\n    return cors;\n  }\n  const observers = [];\n  let observedRoots;\n  const undefinedGroups = new Map();\n  let elementsDefinitionCallback;\n  function collectUndefinedElements(root) {\n    if (!isDefinedSelectorSupported) {\n      return;\n    }\n    forEach(root.querySelectorAll(":not(:defined)"), el => {\n      let tag = el.tagName.toLowerCase();\n      if (!tag.includes("-")) {\n        const extendedTag = el.getAttribute("is");\n        if (extendedTag) {\n          tag = extendedTag;\n        } else {\n          return;\n        }\n      }\n      if (!undefinedGroups.has(tag)) {\n        undefinedGroups.set(tag, new Set());\n        customElementsWhenDefined(tag).then(() => {\n          if (elementsDefinitionCallback) {\n            const elements = undefinedGroups.get(tag);\n            undefinedGroups.delete(tag);\n            elementsDefinitionCallback(Array.from(elements));\n          }\n        });\n      }\n      undefinedGroups.get(tag).add(el);\n    });\n  }\n  let canOptimizeUsingProxy = false;\n  document.addEventListener("__darkreader__inlineScriptsAllowed", () => {\n    canOptimizeUsingProxy = true;\n  });\n  const resolvers = new Map();\n  function handleIsDefined(e) {\n    canOptimizeUsingProxy = true;\n    if (resolvers.has(e.detail.tag)) {\n      const resolve = resolvers.get(e.detail.tag);\n      resolve();\n    }\n  }\n  async function customElementsWhenDefined(tag) {\n    return new Promise(resolve => {\n      if (window.customElements && typeof customElements.whenDefined === "function") {\n        customElements.whenDefined(tag).then(() => resolve());\n      } else if (canOptimizeUsingProxy) {\n        resolvers.set(tag, resolve);\n        document.dispatchEvent(new CustomEvent("__darkreader__addUndefinedResolver", {\n          detail: {\n            tag\n          }\n        }));\n      } else {\n        const checkIfDefined = () => {\n          const elements = undefinedGroups.get(tag);\n          if (elements && elements.size > 0) {\n            if (elements.values().next().value.matches(":defined")) {\n              resolve();\n            } else {\n              requestAnimationFrame(checkIfDefined);\n            }\n          }\n        };\n        requestAnimationFrame(checkIfDefined);\n      }\n    });\n  }\n  function watchWhenCustomElementsDefined(callback) {\n    elementsDefinitionCallback = callback;\n  }\n  function unsubscribeFromDefineCustomElements() {\n    elementsDefinitionCallback = null;\n    undefinedGroups.clear();\n    document.removeEventListener("__darkreader__isDefined", handleIsDefined);\n  }\n  function watchForStyleChanges(currentStyles, update, shadowRootDiscovered) {\n    stopWatchingForStyleChanges();\n    const prevStyles = new Set(currentStyles);\n    const prevStyleSiblings = new WeakMap();\n    const nextStyleSiblings = new WeakMap();\n    function saveStylePosition(style) {\n      prevStyleSiblings.set(style, style.previousElementSibling);\n      nextStyleSiblings.set(style, style.nextElementSibling);\n    }\n    function forgetStylePosition(style) {\n      prevStyleSiblings.delete(style);\n      nextStyleSiblings.delete(style);\n    }\n    function didStylePositionChange(style) {\n      return style.previousElementSibling !== prevStyleSiblings.get(style) || style.nextElementSibling !== nextStyleSiblings.get(style);\n    }\n    currentStyles.forEach(saveStylePosition);\n    function handleStyleOperations(operations) {\n      const {\n        createdStyles,\n        removedStyles,\n        movedStyles\n      } = operations;\n      createdStyles.forEach(s => saveStylePosition(s));\n      movedStyles.forEach(s => saveStylePosition(s));\n      removedStyles.forEach(s => forgetStylePosition(s));\n      createdStyles.forEach(s => prevStyles.add(s));\n      removedStyles.forEach(s => prevStyles.delete(s));\n      if (createdStyles.size + removedStyles.size + movedStyles.size > 0) {\n        update({\n          created: Array.from(createdStyles),\n          removed: Array.from(removedStyles),\n          moved: Array.from(movedStyles),\n          updated: []\n        });\n      }\n    }\n    function handleMinorTreeMutations({\n      additions,\n      moves,\n      deletions\n    }) {\n      const createdStyles = new Set();\n      const removedStyles = new Set();\n      const movedStyles = new Set();\n      additions.forEach(node => getManageableStyles(node).forEach(style => createdStyles.add(style)));\n      deletions.forEach(node => getManageableStyles(node).forEach(style => removedStyles.add(style)));\n      moves.forEach(node => getManageableStyles(node).forEach(style => movedStyles.add(style)));\n      handleStyleOperations({\n        createdStyles,\n        removedStyles,\n        movedStyles\n      });\n      additions.forEach(n => {\n        iterateShadowHosts(n, subscribeForShadowRootChanges);\n        collectUndefinedElements(n);\n      });\n    }\n    function handleHugeTreeMutations(root) {\n      const styles = new Set(getManageableStyles(root));\n      const createdStyles = new Set();\n      const removedStyles = new Set();\n      const movedStyles = new Set();\n      styles.forEach(s => {\n        if (!prevStyles.has(s)) {\n          createdStyles.add(s);\n        }\n      });\n      prevStyles.forEach(s => {\n        if (!styles.has(s)) {\n          removedStyles.add(s);\n        }\n      });\n      styles.forEach(s => {\n        if (!createdStyles.has(s) && !removedStyles.has(s) && didStylePositionChange(s)) {\n          movedStyles.add(s);\n        }\n      });\n      handleStyleOperations({\n        createdStyles,\n        removedStyles,\n        movedStyles\n      });\n      iterateShadowHosts(root, subscribeForShadowRootChanges);\n      collectUndefinedElements(root);\n    }\n    function handleAttributeMutations(mutations) {\n      const updatedStyles = new Set();\n      const removedStyles = new Set();\n      mutations.forEach(m => {\n        const {\n          target\n        } = m;\n        if (target.isConnected) {\n          if (shouldManageStyle(target)) {\n            updatedStyles.add(target);\n          } else if (target instanceof HTMLLinkElement && target.disabled) {\n            removedStyles.add(target);\n          }\n        }\n      });\n      if (updatedStyles.size + removedStyles.size > 0) {\n        update({\n          updated: Array.from(updatedStyles),\n          created: [],\n          removed: Array.from(removedStyles),\n          moved: []\n        });\n      }\n    }\n    function observe(root) {\n      const treeObserver = createOptimizedTreeObserver(root, {\n        onMinorMutations: handleMinorTreeMutations,\n        onHugeMutations: handleHugeTreeMutations\n      });\n      const attrObserver = new MutationObserver(handleAttributeMutations);\n      attrObserver.observe(root, {\n        attributes: true,\n        attributeFilter: ["rel", "disabled", "media"],\n        subtree: true\n      });\n      observers.push(treeObserver, attrObserver);\n      observedRoots.add(root);\n    }\n    function subscribeForShadowRootChanges(node) {\n      const {\n        shadowRoot\n      } = node;\n      if (shadowRoot == null || observedRoots.has(shadowRoot)) {\n        return;\n      }\n      observe(shadowRoot);\n      shadowRootDiscovered(shadowRoot);\n    }\n    observe(document);\n    iterateShadowHosts(document.documentElement, subscribeForShadowRootChanges);\n    watchWhenCustomElementsDefined(hosts => {\n      const newStyles = [];\n      hosts.forEach(host => push(newStyles, getManageableStyles(host.shadowRoot)));\n      update({\n        created: newStyles,\n        updated: [],\n        removed: [],\n        moved: []\n      });\n      hosts.forEach(host => {\n        const {\n          shadowRoot\n        } = host;\n        if (shadowRoot == null) {\n          return;\n        }\n        subscribeForShadowRootChanges(host);\n        iterateShadowHosts(shadowRoot, subscribeForShadowRootChanges);\n        collectUndefinedElements(shadowRoot);\n      });\n    });\n    document.addEventListener("__darkreader__isDefined", handleIsDefined);\n    collectUndefinedElements(document);\n  }\n  function resetObservers() {\n    observers.forEach(o => o.disconnect());\n    observers.splice(0, observers.length);\n    observedRoots = new WeakSet();\n  }\n  function stopWatchingForStyleChanges() {\n    resetObservers();\n    unsubscribeFromDefineCustomElements();\n  }\n  function hexify(number) {\n    return (number < 16 ? "0" : "") + number.toString(16);\n  }\n  function generateUID() {\n    if ("randomUUID" in crypto) {\n      const uuid = crypto.randomUUID();\n      return uuid.substring(0, 8) + uuid.substring(9, 13) + uuid.substring(14, 18) + uuid.substring(19, 23) + uuid.substring(24);\n    }\n    return Array.from(crypto.getRandomValues(new Uint8Array(16))).map(x => hexify(x)).join("");\n  }\n  const adoptedStyleOverrides = new WeakMap();\n  const overrideList = new WeakSet();\n  function createAdoptedStyleSheetOverride(node) {\n    let cancelAsyncOperations = false;\n    function injectSheet(sheet, override) {\n      const newSheets = [...node.adoptedStyleSheets];\n      const sheetIndex = newSheets.indexOf(sheet);\n      const existingIndex = newSheets.indexOf(override);\n      if (sheetIndex === existingIndex - 1) {\n        return;\n      }\n      if (existingIndex >= 0) {\n        newSheets.splice(existingIndex, 1);\n      }\n      newSheets.splice(sheetIndex + 1, 0, override);\n      node.adoptedStyleSheets = newSheets;\n    }\n    function destroy() {\n      cancelAsyncOperations = true;\n      const newSheets = [...node.adoptedStyleSheets];\n      node.adoptedStyleSheets.forEach(adoptedStyleSheet => {\n        if (overrideList.has(adoptedStyleSheet)) {\n          const existingIndex = newSheets.indexOf(adoptedStyleSheet);\n          if (existingIndex >= 0) {\n            newSheets.splice(existingIndex, 1);\n          }\n          adoptedStyleOverrides.delete(adoptedStyleSheet);\n          overrideList.delete(adoptedStyleSheet);\n        }\n      });\n      node.adoptedStyleSheets = newSheets;\n    }\n    function render(theme, ignoreImageAnalysis) {\n      node.adoptedStyleSheets.forEach(sheet => {\n        if (overrideList.has(sheet)) {\n          return;\n        }\n        const rules = sheet.rules;\n        const override = new CSSStyleSheet();\n        function prepareOverridesSheet() {\n          for (let i = override.cssRules.length - 1; i >= 0; i--) {\n            override.deleteRule(i);\n          }\n          injectSheet(sheet, override);\n          adoptedStyleOverrides.set(sheet, override);\n          overrideList.add(override);\n          return override;\n        }\n        const sheetModifier = createStyleSheetModifier();\n        sheetModifier.modifySheet({\n          prepareSheet: prepareOverridesSheet,\n          sourceCSSRules: rules,\n          theme,\n          ignoreImageAnalysis,\n          force: false,\n          isAsyncCancelled: () => cancelAsyncOperations\n        });\n      });\n    }\n    return {\n      render,\n      destroy\n    };\n  }\n  function injectProxy() {\n    document.dispatchEvent(new CustomEvent("__darkreader__inlineScriptsAllowed"));\n    const addRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, "addRule");\n    const insertRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, "insertRule");\n    const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, "deleteRule");\n    const removeRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, "removeRule");\n    const documentStyleSheetsDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, "styleSheets");\n    const shouldWrapHTMLElement = location.hostname.endsWith("baidu.com");\n    const getElementsByTagNameDescriptor = shouldWrapHTMLElement ? Object.getOwnPropertyDescriptor(Element.prototype, "getElementsByTagName") : null;\n    const cleanUp = () => {\n      Object.defineProperty(CSSStyleSheet.prototype, "addRule", addRuleDescriptor);\n      Object.defineProperty(CSSStyleSheet.prototype, "insertRule", insertRuleDescriptor);\n      Object.defineProperty(CSSStyleSheet.prototype, "deleteRule", deleteRuleDescriptor);\n      Object.defineProperty(CSSStyleSheet.prototype, "removeRule", removeRuleDescriptor);\n      document.removeEventListener("__darkreader__cleanUp", cleanUp);\n      document.removeEventListener("__darkreader__addUndefinedResolver", addUndefinedResolver);\n      Object.defineProperty(Document.prototype, "styleSheets", documentStyleSheetsDescriptor);\n      if (shouldWrapHTMLElement) {\n        Object.defineProperty(Element.prototype, "getElementsByTagName", getElementsByTagNameDescriptor);\n      }\n    };\n    const addUndefinedResolver = e => {\n      customElements.whenDefined(e.detail.tag).then(() => {\n        document.dispatchEvent(new CustomEvent("__darkreader__isDefined", {\n          detail: {\n            tag: e.detail.tag\n          }\n        }));\n      });\n    };\n    document.addEventListener("__darkreader__cleanUp", cleanUp);\n    document.addEventListener("__darkreader__addUndefinedResolver", addUndefinedResolver);\n    const updateSheetEvent = new Event("__darkreader__updateSheet");\n    function proxyAddRule(selector, style, index) {\n      addRuleDescriptor.value.call(this, selector, style, index);\n      if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {\n        this.ownerNode.dispatchEvent(updateSheetEvent);\n      }\n      return -1;\n    }\n    function proxyInsertRule(rule, index) {\n      const returnValue = insertRuleDescriptor.value.call(this, rule, index);\n      if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {\n        this.ownerNode.dispatchEvent(updateSheetEvent);\n      }\n      return returnValue;\n    }\n    function proxyDeleteRule(index) {\n      deleteRuleDescriptor.value.call(this, index);\n      if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {\n        this.ownerNode.dispatchEvent(updateSheetEvent);\n      }\n    }\n    function proxyRemoveRule(index) {\n      removeRuleDescriptor.value.call(this, index);\n      if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {\n        this.ownerNode.dispatchEvent(updateSheetEvent);\n      }\n    }\n    function proxyDocumentStyleSheets() {\n      const docSheets = documentStyleSheetsDescriptor.get.call(this);\n      const filtered = [...docSheets].filter(styleSheet => {\n        return !styleSheet.ownerNode.classList.contains("darkreader");\n      });\n      return Object.setPrototypeOf(filtered, StyleSheetList.prototype);\n    }\n    function proxyGetElementsByTagName(tagName) {\n      const getCurrentElementValue = () => {\n        let elements = getElementsByTagNameDescriptor.value.call(this, tagName);\n        if (tagName === "style") {\n          elements = Object.setPrototypeOf([...elements].filter(element => {\n            return !element.classList.contains("darkreader");\n          }), NodeList.prototype);\n        }\n        return elements;\n      };\n      let elements = getCurrentElementValue();\n      const NodeListBehavior = {\n        get: function (_, property) {\n          return getCurrentElementValue()[Number(property)];\n        }\n      };\n      elements = new Proxy(elements, NodeListBehavior);\n      return elements;\n    }\n    Object.defineProperty(CSSStyleSheet.prototype, "addRule", Object.assign({}, addRuleDescriptor, {\n      value: proxyAddRule\n    }));\n    Object.defineProperty(CSSStyleSheet.prototype, "insertRule", Object.assign({}, insertRuleDescriptor, {\n      value: proxyInsertRule\n    }));\n    Object.defineProperty(CSSStyleSheet.prototype, "deleteRule", Object.assign({}, deleteRuleDescriptor, {\n      value: proxyDeleteRule\n    }));\n    Object.defineProperty(CSSStyleSheet.prototype, "removeRule", Object.assign({}, removeRuleDescriptor, {\n      value: proxyRemoveRule\n    }));\n    Object.defineProperty(Document.prototype, "styleSheets", Object.assign({}, documentStyleSheetsDescriptor, {\n      get: proxyDocumentStyleSheets\n    }));\n    if (shouldWrapHTMLElement) {\n      Object.defineProperty(Element.prototype, "getElementsByTagName", Object.assign({}, getElementsByTagNameDescriptor, {\n        value: proxyGetElementsByTagName\n      }));\n    }\n  }\n  const INSTANCE_ID = generateUID();\n  const styleManagers = new Map();\n  const adoptedStyleManagers = [];\n  let filter = null;\n  let fixes = null;\n  let ignoredImageAnalysisSelectors = null;\n  let ignoredInlineSelectors = null;\n  function createOrUpdateStyle(className, root = document.head || document) {\n    let element = root.querySelector(`.${className}`);\n    if (!element) {\n      element = document.createElement("style");\n      element.classList.add("darkreader");\n      element.classList.add(className);\n      element.media = "screen";\n      element.textContent = "";\n    }\n    return element;\n  }\n  function createOrUpdateScript(className, root = document.head || document) {\n    let element = root.querySelector(`.${className}`);\n    if (!element) {\n      element = document.createElement("script");\n      element.classList.add("darkreader");\n      element.classList.add(className);\n    }\n    return element;\n  }\n  const nodePositionWatchers = new Map();\n  function setupNodePositionWatcher(node, alias) {\n    nodePositionWatchers.has(alias) && nodePositionWatchers.get(alias).stop();\n    nodePositionWatchers.set(alias, watchForNodePosition(node, "parent"));\n  }\n  function stopStylePositionWatchers() {\n    forEach(nodePositionWatchers.values(), watcher => watcher.stop());\n    nodePositionWatchers.clear();\n  }\n  function createStaticStyleOverrides() {\n    const fallbackStyle = createOrUpdateStyle("darkreader--fallback", document);\n    fallbackStyle.textContent = getModifiedFallbackStyle(filter, {\n      strict: true\n    });\n    document.head.insertBefore(fallbackStyle, document.head.firstChild);\n    setupNodePositionWatcher(fallbackStyle, "fallback");\n    const userAgentStyle = createOrUpdateStyle("darkreader--user-agent");\n    userAgentStyle.textContent = getModifiedUserAgentStyle(filter, isIFrame, filter.styleSystemControls);\n    document.head.insertBefore(userAgentStyle, fallbackStyle.nextSibling);\n    setupNodePositionWatcher(userAgentStyle, "user-agent");\n    const textStyle = createOrUpdateStyle("darkreader--text");\n    if (filter.useFont || filter.textStroke > 0) {\n      textStyle.textContent = createTextStyle(filter);\n    } else {\n      textStyle.textContent = "";\n    }\n    document.head.insertBefore(textStyle, fallbackStyle.nextSibling);\n    setupNodePositionWatcher(textStyle, "text");\n    const invertStyle = createOrUpdateStyle("darkreader--invert");\n    if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {\n      invertStyle.textContent = [`${fixes.invert.join(", ")} {`, `    filter: ${getCSSFilterValue({\n        ...filter,\n        contrast: filter.mode === 0 ? filter.contrast : clamp(filter.contrast - 10, 0, 100)\n      })} !important;`, "}"].join("\\n");\n    } else {\n      invertStyle.textContent = "";\n    }\n    document.head.insertBefore(invertStyle, textStyle.nextSibling);\n    setupNodePositionWatcher(invertStyle, "invert");\n    const inlineStyle = createOrUpdateStyle("darkreader--inline");\n    inlineStyle.textContent = getInlineOverrideStyle();\n    document.head.insertBefore(inlineStyle, invertStyle.nextSibling);\n    setupNodePositionWatcher(inlineStyle, "inline");\n    const overrideStyle = createOrUpdateStyle("darkreader--override");\n    overrideStyle.textContent = fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";\n    document.head.appendChild(overrideStyle);\n    setupNodePositionWatcher(overrideStyle, "override");\n    const variableStyle = createOrUpdateStyle("darkreader--variables");\n    const selectionColors = getSelectionColor(filter);\n    const {\n      darkSchemeBackgroundColor,\n      darkSchemeTextColor,\n      lightSchemeBackgroundColor,\n      lightSchemeTextColor,\n      mode\n    } = filter;\n    let schemeBackgroundColor = mode === 0 ? lightSchemeBackgroundColor : darkSchemeBackgroundColor;\n    let schemeTextColor = mode === 0 ? lightSchemeTextColor : darkSchemeTextColor;\n    schemeBackgroundColor = modifyBackgroundColor(parse(schemeBackgroundColor), filter);\n    schemeTextColor = modifyForegroundColor(parse(schemeTextColor), filter);\n    variableStyle.textContent = [`:root {`, `   --darkreader-neutral-background: ${schemeBackgroundColor};`, `   --darkreader-neutral-text: ${schemeTextColor};`, `   --darkreader-selection-background: ${selectionColors.backgroundColorSelection};`, `   --darkreader-selection-text: ${selectionColors.foregroundColorSelection};`, `}`].join("\\n");\n    document.head.insertBefore(variableStyle, inlineStyle.nextSibling);\n    setupNodePositionWatcher(variableStyle, "variables");\n    const rootVarsStyle = createOrUpdateStyle("darkreader--root-vars");\n    document.head.insertBefore(rootVarsStyle, variableStyle.nextSibling);\n    const proxyScript = createOrUpdateScript("darkreader--proxy");\n    proxyScript.append(`(${injectProxy})()`);\n    document.head.insertBefore(proxyScript, rootVarsStyle.nextSibling);\n    proxyScript.remove();\n  }\n  const shadowRootsWithOverrides = new Set();\n  function createShadowStaticStyleOverrides(root) {\n    const inlineStyle = createOrUpdateStyle("darkreader--inline", root);\n    inlineStyle.textContent = getInlineOverrideStyle();\n    root.insertBefore(inlineStyle, root.firstChild);\n    const overrideStyle = createOrUpdateStyle("darkreader--override", root);\n    overrideStyle.textContent = fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";\n    root.insertBefore(overrideStyle, inlineStyle.nextSibling);\n    const invertStyle = createOrUpdateStyle("darkreader--invert", root);\n    if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {\n      invertStyle.textContent = [`${fixes.invert.join(", ")} {`, `    filter: ${getCSSFilterValue({\n        ...filter,\n        contrast: filter.mode === 0 ? filter.contrast : clamp(filter.contrast - 10, 0, 100)\n      })} !important;`, "}"].join("\\n");\n    } else {\n      invertStyle.textContent = "";\n    }\n    root.insertBefore(invertStyle, overrideStyle.nextSibling);\n    shadowRootsWithOverrides.add(root);\n  }\n  function replaceCSSTemplates($cssText) {\n    return $cssText.replace(/\\${(.+?)}/g, (_, $color) => {\n      const color = tryParseColor($color);\n      if (color) {\n        return modifyColor(color, filter);\n      }\n      return $color;\n    });\n  }\n  function cleanFallbackStyle() {\n    const fallback = document.querySelector(".darkreader--fallback");\n    if (fallback) {\n      fallback.textContent = "";\n    }\n  }\n  function createDynamicStyleOverrides() {\n    cancelRendering();\n    const allStyles = getManageableStyles(document);\n    const newManagers = allStyles.filter(style => !styleManagers.has(style)).map(style => createManager(style));\n    newManagers.map(manager => manager.details()).filter(detail => detail && detail.rules.length > 0).forEach(detail => {\n      variablesStore.addRulesForMatching(detail.rules);\n    });\n    variablesStore.matchVariablesAndDependants();\n    variablesStore.setOnRootVariableChange(() => {\n      variablesStore.putRootVars(document.head.querySelector(".darkreader--root-vars"), filter);\n    });\n    variablesStore.putRootVars(document.head.querySelector(".darkreader--root-vars"), filter);\n    styleManagers.forEach(manager => manager.render(filter, ignoredImageAnalysisSelectors));\n    if (loadingStyles.size === 0) {\n      cleanFallbackStyle();\n    }\n    newManagers.forEach(manager => manager.watch());\n    const inlineStyleElements = toArray(document.querySelectorAll(INLINE_STYLE_SELECTOR));\n    iterateShadowHosts(document.documentElement, host => {\n      createShadowStaticStyleOverrides(host.shadowRoot);\n      const elements = host.shadowRoot.querySelectorAll(INLINE_STYLE_SELECTOR);\n      if (elements.length > 0) {\n        push(inlineStyleElements, elements);\n      }\n    });\n    inlineStyleElements.forEach(el => overrideInlineStyle(el, filter, ignoredInlineSelectors, ignoredImageAnalysisSelectors));\n    handleAdoptedStyleSheets(document);\n  }\n  let loadingStylesCounter = 0;\n  const loadingStyles = new Set();\n  function createManager(element) {\n    const loadingStyleId = ++loadingStylesCounter;\n    function loadingStart() {\n      if (!isDOMReady() || !didDocumentShowUp) {\n        loadingStyles.add(loadingStyleId);\n        logInfo(`Current amount of styles loading: ${loadingStyles.size}`);\n        const fallbackStyle = document.querySelector(".darkreader--fallback");\n        if (!fallbackStyle.textContent) {\n          fallbackStyle.textContent = getModifiedFallbackStyle(filter, {\n            strict: false\n          });\n        }\n      }\n    }\n    function loadingEnd() {\n      loadingStyles.delete(loadingStyleId);\n      logInfo(`Removed loadingStyle ${loadingStyleId}, now awaiting: ${loadingStyles.size}`);\n      if (loadingStyles.size === 0 && isDOMReady()) {\n        cleanFallbackStyle();\n      }\n    }\n    function update() {\n      const details = manager.details();\n      if (!details) {\n        return;\n      }\n      variablesStore.addRulesForMatching(details.rules);\n      variablesStore.matchVariablesAndDependants();\n      manager.render(filter, ignoredImageAnalysisSelectors);\n    }\n    const manager = manageStyle(element, {\n      update,\n      loadingStart,\n      loadingEnd\n    });\n    styleManagers.set(element, manager);\n    return manager;\n  }\n  function removeManager(element) {\n    const manager = styleManagers.get(element);\n    if (manager) {\n      manager.destroy();\n      styleManagers.delete(element);\n    }\n  }\n  const throttledRenderAllStyles = throttle(callback => {\n    styleManagers.forEach(manager => manager.render(filter, ignoredImageAnalysisSelectors));\n    adoptedStyleManagers.forEach(manager => manager.render(filter, ignoredImageAnalysisSelectors));\n    callback && callback();\n  });\n  const cancelRendering = function () {\n    throttledRenderAllStyles.cancel();\n  };\n  function onDOMReady() {\n    if (loadingStyles.size === 0) {\n      cleanFallbackStyle();\n      return;\n    }\n  }\n  let documentVisibilityListener = null;\n  let didDocumentShowUp = !document.hidden;\n  function watchForDocumentVisibility(callback) {\n    const alreadyWatching = Boolean(documentVisibilityListener);\n    documentVisibilityListener = () => {\n      if (!document.hidden) {\n        stopWatchingForDocumentVisibility();\n        callback();\n        didDocumentShowUp = true;\n      }\n    };\n    if (!alreadyWatching) {\n      document.addEventListener("visibilitychange", documentVisibilityListener);\n    }\n  }\n  function stopWatchingForDocumentVisibility() {\n    document.removeEventListener("visibilitychange", documentVisibilityListener);\n    documentVisibilityListener = null;\n  }\n  function createThemeAndWatchForUpdates() {\n    createStaticStyleOverrides();\n    function runDynamicStyle() {\n      createDynamicStyleOverrides();\n      watchForUpdates();\n    }\n    if (document.hidden && !filter.immediateModify) {\n      watchForDocumentVisibility(runDynamicStyle);\n    } else {\n      runDynamicStyle();\n    }\n    changeMetaThemeColorWhenAvailable(filter);\n  }\n  function handleAdoptedStyleSheets(node) {\n    if (Array.isArray(node.adoptedStyleSheets)) {\n      if (node.adoptedStyleSheets.length > 0) {\n        const newManger = createAdoptedStyleSheetOverride(node);\n        adoptedStyleManagers.push(newManger);\n        newManger.render(filter, ignoredImageAnalysisSelectors);\n      }\n    }\n  }\n  function watchForUpdates() {\n    const managedStyles = Array.from(styleManagers.keys());\n    watchForStyleChanges(managedStyles, ({\n      created,\n      updated,\n      removed,\n      moved\n    }) => {\n      const stylesToRemove = removed;\n      const stylesToManage = created.concat(updated).concat(moved).filter(style => !styleManagers.has(style));\n      const stylesToRestore = moved.filter(style => styleManagers.has(style));\n      stylesToRemove.forEach(style => removeManager(style));\n      const newManagers = stylesToManage.map(style => createManager(style));\n      newManagers.map(manager => manager.details()).filter(detail => detail && detail.rules.length > 0).forEach(detail => {\n        variablesStore.addRulesForMatching(detail.rules);\n      });\n      variablesStore.matchVariablesAndDependants();\n      newManagers.forEach(manager => manager.render(filter, ignoredImageAnalysisSelectors));\n      newManagers.forEach(manager => manager.watch());\n      stylesToRestore.forEach(style => styleManagers.get(style).restore());\n    }, shadowRoot => {\n      createShadowStaticStyleOverrides(shadowRoot);\n      handleAdoptedStyleSheets(shadowRoot);\n    });\n    watchForInlineStyles(element => {\n      overrideInlineStyle(element, filter, ignoredInlineSelectors, ignoredImageAnalysisSelectors);\n      if (element === document.documentElement) {\n        const styleAttr = element.getAttribute("style");\n        if (styleAttr.includes("--")) {\n          variablesStore.matchVariablesAndDependants();\n          variablesStore.putRootVars(document.head.querySelector(".darkreader--root-vars"), filter);\n        }\n      }\n    }, root => {\n      createShadowStaticStyleOverrides(root);\n      const inlineStyleElements = root.querySelectorAll(INLINE_STYLE_SELECTOR);\n      if (inlineStyleElements.length > 0) {\n        forEach(inlineStyleElements, el => overrideInlineStyle(el, filter, ignoredInlineSelectors, ignoredImageAnalysisSelectors));\n      }\n    });\n    addDOMReadyListener(onDOMReady);\n  }\n  function stopWatchingForUpdates() {\n    styleManagers.forEach(manager => manager.pause());\n    stopStylePositionWatchers();\n    stopWatchingForStyleChanges();\n    stopWatchingForInlineStyles();\n    removeDOMReadyListener(onDOMReady);\n    cleanReadyStateCompleteListeners();\n  }\n  function createDarkReaderInstanceMarker() {\n    const metaElement = document.createElement("meta");\n    metaElement.name = "darkreader";\n    metaElement.content = INSTANCE_ID;\n    document.head.appendChild(metaElement);\n  }\n  function isAnotherDarkReaderInstanceActive() {\n    const meta = document.querySelector(\'meta[name="darkreader"]\');\n    if (meta) {\n      if (meta.content !== INSTANCE_ID) {\n        return true;\n      }\n      return false;\n    }\n    createDarkReaderInstanceMarker();\n    return false;\n  }\n  function createOrUpdateDynamicTheme(filterConfig, dynamicThemeFixes, isIframe) {\n    filter = filterConfig;\n    fixes = dynamicThemeFixes;\n    if (fixes) {\n      ignoredImageAnalysisSelectors = Array.isArray(fixes.ignoreImageAnalysis) ? fixes.ignoreImageAnalysis : [];\n      ignoredInlineSelectors = Array.isArray(fixes.ignoreInlineStyle) ? fixes.ignoreInlineStyle : [];\n    } else {\n      ignoredImageAnalysisSelectors = [];\n      ignoredInlineSelectors = [];\n    }\n    isIFrame = isIframe;\n    if (filter.immediateModify) {\n      setIsDOMReady(() => {\n        return true;\n      });\n    }\n    if (document.head) {\n      if (isAnotherDarkReaderInstanceActive()) {\n        return;\n      }\n      document.documentElement.setAttribute("data-darkreader-mode", "dynamic");\n      document.documentElement.setAttribute("data-darkreader-scheme", filter.mode ? "dark" : "dimmed");\n      createThemeAndWatchForUpdates();\n    } else {\n      if (isSafari) {\n        const fallbackStyle = createOrUpdateStyle("darkreader--fallback");\n        document.documentElement.appendChild(fallbackStyle);\n        fallbackStyle.textContent = getModifiedFallbackStyle(filter, {\n          strict: true\n        });\n      }\n      const headObserver = new MutationObserver(() => {\n        if (document.head) {\n          headObserver.disconnect();\n          if (isAnotherDarkReaderInstanceActive()) {\n            removeDynamicTheme();\n            return;\n          }\n          createThemeAndWatchForUpdates();\n        }\n      });\n      headObserver.observe(document, {\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n  function removeProxy() {\n    document.dispatchEvent(new CustomEvent("__darkreader__cleanUp"));\n    removeNode(document.head.querySelector(".darkreader--proxy"));\n  }\n  function removeDynamicTheme() {\n    document.documentElement.removeAttribute(`data-darkreader-mode`);\n    document.documentElement.removeAttribute(`data-darkreader-scheme`);\n    cleanDynamicThemeCache();\n    removeNode(document.querySelector(".darkreader--fallback"));\n    if (document.head) {\n      restoreMetaThemeColor();\n      removeNode(document.head.querySelector(".darkreader--user-agent"));\n      removeNode(document.head.querySelector(".darkreader--text"));\n      removeNode(document.head.querySelector(".darkreader--invert"));\n      removeNode(document.head.querySelector(".darkreader--inline"));\n      removeNode(document.head.querySelector(".darkreader--override"));\n      removeNode(document.head.querySelector(".darkreader--variables"));\n      removeNode(document.head.querySelector(".darkreader--root-vars"));\n      removeNode(document.head.querySelector(\'meta[name="darkreader"]\'));\n      removeProxy();\n    }\n    shadowRootsWithOverrides.forEach(root => {\n      removeNode(root.querySelector(".darkreader--inline"));\n      removeNode(root.querySelector(".darkreader--override"));\n    });\n    shadowRootsWithOverrides.clear();\n    forEach(styleManagers.keys(), el => removeManager(el));\n    loadingStyles.clear();\n    cleanLoadingLinks();\n    forEach(document.querySelectorAll(".darkreader"), removeNode);\n    adoptedStyleManagers.forEach(manager => {\n      manager.destroy();\n    });\n    adoptedStyleManagers.splice(0);\n  }\n  function cleanDynamicThemeCache() {\n    variablesStore.clear();\n    parsedURLCache.clear();\n    stopWatchingForDocumentVisibility();\n    cancelRendering();\n    stopWatchingForUpdates();\n    cleanModificationCache();\n  }\n  function darkModeInit() {\n    if (document.documentElement instanceof HTMLHtmlElement && matchMedia("(prefers-color-scheme: dark)").matches) {\n      const css = \'html, body, body :not(iframe):not(div[style^="position:absolute;top:0;left:-"]) { background-color: #181a1b !important; border-color: #776e62 !important; color: #e8e6e3 !important; } html, body { opacity: 1 !important; transition: none !important; }\';\n      let fallback = document.querySelector(".darkreader--fallback");\n      if (fallback) {\n        fallback.textContent = css;\n      } else {\n        fallback = document.createElement("style");\n        fallback.classList.add("darkreader");\n        fallback.classList.add("darkreader--fallback");\n        fallback.media = "screen";\n        fallback.textContent = css;\n        if (document.head) {\n          document.head.append(fallback);\n        } else {\n          const root = document.documentElement;\n          root.append(fallback);\n          const observer = new MutationObserver(() => {\n            if (document.head) {\n              observer.disconnect();\n              if (fallback.isConnected) {\n                document.head.append(fallback);\n              }\n            }\n          });\n          observer.observe(root, {\n            childList: true\n          });\n        }\n      }\n    }\n  }\n  function getDomain(url) {\n    try {\n      return new URL(url).hostname.toLowerCase();\n    } catch (error) {\n      return url.split("/")[0].toLowerCase();\n    }\n  }\n  let browserDomain = getDomain(window.location.href);\n  function setupDarkmode(data) {\n    const {\n      theme,\n      fixes,\n      isIFrame,\n      detectDarkTheme\n    } = data;\n    // console.log("fixes===",fixes.css);\n    removeStyle();\n    createOrUpdateDynamicTheme(theme, fixes, isIFrame);\n    if (detectDarkTheme) {\n      runDarkThemeDetector(hasDarkTheme => {\n        if (hasDarkTheme) {\n          removeDynamicTheme();\n          // onDarkThemeDetected();\n        }\n      });\n    }\n  }\n\n  function onDarkThemeDetected() {\n    sendMessage({\n      type: MessageType.CS_DARK_THEME_DETECTED\n    });\n  }\n  function cleanupDarkmode() {\n    cleanFallbackStyle();\n    removeStyle();\n    removeSVGFilter();\n    removeDynamicTheme();\n    stopDarkThemeDetector();\n  }\n  function is_dark() {\n    return window.matchMedia && window.matchMedia(\'(prefers-color-scheme: dark)\').matches;\n  }\n  let unloaded = false;\n  let colorSchemeWatcher = watchForColorSchemeChange(({\n    isDark\n  }) => {\n    sendMessage({\n      type: "darkmode",\n      operate: MessageType.CS_COLOR_SCHEME_CHANGE,\n      data: {\n        isDark\n      }\n    });\n  });\n  function cleanup() {\n    unloaded = true;\n    // removeEventListener("pagehide", onPageHide);\n    // removeEventListener("freeze", onFreeze);\n    // removeEventListener("resume", onResume);\n    cleanDynamicThemeCache();\n    stopDarkThemeDetector();\n    if (colorSchemeWatcher) {\n      colorSchemeWatcher.disconnect();\n      colorSchemeWatcher = null;\n    }\n  }\n  function sendMessage(message) {\n    if (unloaded) {\n      return;\n    }\n    try {\n      browser.runtime.sendMessage(message, response => {\n        if (response === "unsupportedSender") {\n          cleanupDarkmode();\n        }\n      });\n    } catch (e) {\n      cleanup();\n    }\n  }\n  function watchForColorSchemeChange(callback) {\n    const query = matchMedia("(prefers-color-scheme: dark)");\n    const onChange = () => callback({\n      isDark: query.matches\n    });\n    if (isMatchMediaChangeEventListenerSupported) {\n      query.addEventListener("change", onChange);\n    } else {\n      query.addListener(onChange);\n    }\n    return {\n      disconnect() {\n        if (isMatchMediaChangeEventListenerSupported) {\n          query.removeEventListener("change", onChange);\n        } else {\n          query.removeListener(onChange);\n        }\n      }\n    };\n  }\n\n  // function onPageHide(e) {\n  //     if (e.persisted === false) {\n  //         sendMessage({type: MessageType.CS_FRAME_FORGET});\n  //     }\n  // }\n  // function onFreeze() {\n  //     sendMessage({type: MessageType.CS_FRAME_FREEZE});\n  // }\n  // function onResume() {\n  //     sendMessage({type: MessageType.CS_FRAME_RESUME});\n  // }\n  // if(isSafari){\n  //     addEventListener("pagehide", onPageHide);\n  //     addEventListener("freeze", onFreeze);\n  //     addEventListener("resume", onResume);\n  // }\n\n  browser.runtime.sendMessage({\n    type: "darkmode",\n    operate: MessageType.CS_FRAME_CONNECT\n  }, function (response) {});\n  browser.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    const {\n      type,\n      data,\n      stayDarkSettings,\n      darkSetings,\n      error,\n      id,\n      from,\n      operate\n    } = request;\n    // console.log("data===request=",request);\n    if (MessageType.BG_FETCH_RESPONSE === type) {\n      const resolve = resolvers$1.get(id);\n      const reject = rejectors.get(id);\n      resolvers$1.delete(id);\n      rejectors.delete(id);\n      if (error) {\n        reject && reject(error);\n      } else {\n        resolve && resolve(data);\n      }\n    } else if (MessageType.BG_ADD_DYNAMIC_THEME === type) {\n      // console.log("data==BG_ADD_DYNAMIC_THEME===",data, stayDarkSettings);\n      if (document.querySelector(".noir") && document.querySelector(".noir-root")) {\n        cleanupDarkmode();\n      } else {\n        setupDarkmode(data);\n      }\n      handleDarkSettingsForStorage(darkSetings);\n    } else if (MessageType.BG_CLEAN_UP === type) {\n      // console.log("data==BG_CLEAN_UP===",stayDarkSettings);\n      cleanupDarkmode();\n      handleDarkSettingsForStorage(darkSetings);\n    }\n    return true;\n  });\n  async function handleDarkSettingsForStorage(darkSetings) {\n    // console.log("handleDarkSettingsForStorage-----", darkSetings);\n    window.localStorage.setItem("FETCH_DARK_SETTING", JSON.stringify(darkSetings));\n  }\n})();\n/* eslint-disable */\n\n//# sourceURL=webpack://stay-popup/./src/darkmode/dark.user.js?')},"./node_modules/core-js/internals/a-callable.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw $TypeError(tryToString(argument) + \' is not a function\');\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/a-callable.js?')},"./node_modules/core-js/internals/a-possible-prototype.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\nmodule.exports = function (argument) {\n  if (typeof argument == 'object' || isCallable(argument)) return argument;\n  throw $TypeError(\"Can't set \" + $String(argument) + ' as a prototype');\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/a-possible-prototype.js?")},"./node_modules/core-js/internals/an-instance.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ \"./node_modules/core-js/internals/object-is-prototype-of.js\");\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (it, Prototype) {\n  if (isPrototypeOf(Prototype, it)) return it;\n  throw $TypeError('Incorrect invocation');\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/an-instance.js?")},"./node_modules/core-js/internals/an-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw $TypeError($String(argument) + ' is not an object');\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/an-object.js?")},"./node_modules/core-js/internals/array-includes.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/array-includes.js?')},"./node_modules/core-js/internals/array-set-length.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar isArray = __webpack_require__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Safari < 13 does not throw an error in this case\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {\n  // makes no sense without proper strict mode support\n  if (this !== undefined) return true;\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).length = 1;\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\nmodule.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {\n    throw $TypeError('Cannot set read only .length');\n  } return O.length = length;\n} : function (O, length) {\n  return O.length = length;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/array-set-length.js?")},"./node_modules/core-js/internals/classof-raw.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/classof-raw.js?")},"./node_modules/core-js/internals/classof.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar classofRaw = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/classof.js?")},"./node_modules/core-js/internals/copy-constructor-properties.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/copy-constructor-properties.js?')},"./node_modules/core-js/internals/create-non-enumerable-property.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/create-non-enumerable-property.js?')},"./node_modules/core-js/internals/create-property-descriptor.js":module=>{eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/create-property-descriptor.js?")},"./node_modules/core-js/internals/define-built-in.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/define-built-in.js?')},"./node_modules/core-js/internals/define-global-property.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/define-global-property.js?')},"./node_modules/core-js/internals/descriptors.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// Detect IE8\'s incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/descriptors.js?')},"./node_modules/core-js/internals/document-all.js":module=>{eval("var documentAll = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;\n\nmodule.exports = {\n  all: documentAll,\n  IS_HTMLDDA: IS_HTMLDDA\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/document-all.js?")},"./node_modules/core-js/internals/document-create-element.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar document = global.document;\n// typeof document.createElement is \'object\' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/document-create-element.js?')},"./node_modules/core-js/internals/does-not-exceed-safe-integer.js":module=>{eval("var $TypeError = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n\nmodule.exports = function (it) {\n  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');\n  return it;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/does-not-exceed-safe-integer.js?")},"./node_modules/core-js/internals/dom-exception-constants.js":module=>{eval("module.exports = {\n  IndexSizeError: { s: 'INDEX_SIZE_ERR', c: 1, m: 1 },\n  DOMStringSizeError: { s: 'DOMSTRING_SIZE_ERR', c: 2, m: 0 },\n  HierarchyRequestError: { s: 'HIERARCHY_REQUEST_ERR', c: 3, m: 1 },\n  WrongDocumentError: { s: 'WRONG_DOCUMENT_ERR', c: 4, m: 1 },\n  InvalidCharacterError: { s: 'INVALID_CHARACTER_ERR', c: 5, m: 1 },\n  NoDataAllowedError: { s: 'NO_DATA_ALLOWED_ERR', c: 6, m: 0 },\n  NoModificationAllowedError: { s: 'NO_MODIFICATION_ALLOWED_ERR', c: 7, m: 1 },\n  NotFoundError: { s: 'NOT_FOUND_ERR', c: 8, m: 1 },\n  NotSupportedError: { s: 'NOT_SUPPORTED_ERR', c: 9, m: 1 },\n  InUseAttributeError: { s: 'INUSE_ATTRIBUTE_ERR', c: 10, m: 1 },\n  InvalidStateError: { s: 'INVALID_STATE_ERR', c: 11, m: 1 },\n  SyntaxError: { s: 'SYNTAX_ERR', c: 12, m: 1 },\n  InvalidModificationError: { s: 'INVALID_MODIFICATION_ERR', c: 13, m: 1 },\n  NamespaceError: { s: 'NAMESPACE_ERR', c: 14, m: 1 },\n  InvalidAccessError: { s: 'INVALID_ACCESS_ERR', c: 15, m: 1 },\n  ValidationError: { s: 'VALIDATION_ERR', c: 16, m: 0 },\n  TypeMismatchError: { s: 'TYPE_MISMATCH_ERR', c: 17, m: 1 },\n  SecurityError: { s: 'SECURITY_ERR', c: 18, m: 1 },\n  NetworkError: { s: 'NETWORK_ERR', c: 19, m: 1 },\n  AbortError: { s: 'ABORT_ERR', c: 20, m: 1 },\n  URLMismatchError: { s: 'URL_MISMATCH_ERR', c: 21, m: 1 },\n  QuotaExceededError: { s: 'QUOTA_EXCEEDED_ERR', c: 22, m: 1 },\n  TimeoutError: { s: 'TIMEOUT_ERR', c: 23, m: 1 },\n  InvalidNodeTypeError: { s: 'INVALID_NODE_TYPE_ERR', c: 24, m: 1 },\n  DataCloneError: { s: 'DATA_CLONE_ERR', c: 25, m: 1 }\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/dom-exception-constants.js?")},"./node_modules/core-js/internals/engine-user-agent.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/engine-user-agent.js?")},"./node_modules/core-js/internals/engine-v8-version.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split(\'.\');\n  // in old Chrome, versions of V8 isn\'t V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/engine-v8-version.js?')},"./node_modules/core-js/internals/enum-bug-keys.js":module=>{eval("// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/enum-bug-keys.js?")},"./node_modules/core-js/internals/error-stack-clear.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nvar $Error = Error;\nvar replace = uncurryThis(''.replace);\n\nvar TEST = (function (arg) { return String($Error(arg).stack); })('zxcasd');\nvar V8_OR_CHAKRA_STACK_ENTRY = /\\n\\s*at [^:]*:[^\\n]*/;\nvar IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);\n\nmodule.exports = function (stack, dropEntries) {\n  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {\n    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');\n  } return stack;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/error-stack-clear.js?")},"./node_modules/core-js/internals/export.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \'.\' : \'#\') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, \'sham\', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/export.js?')},"./node_modules/core-js/internals/fails.js":module=>{eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/fails.js?")},"./node_modules/core-js/internals/function-bind-native.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/function-bind-native.js?")},"./node_modules/core-js/internals/function-call.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/function-call.js?')},"./node_modules/core-js/internals/function-name.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/function-name.js?")},"./node_modules/core-js/internals/function-uncurry-this.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call.apply(fn, arguments);\n  };\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/function-uncurry-this.js?')},"./node_modules/core-js/internals/get-built-in.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/get-built-in.js?')},"./node_modules/core-js/internals/get-method.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/get-method.js?')},"./node_modules/core-js/internals/global.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/global.js?")},"./node_modules/core-js/internals/has-own-property.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/has-own-property.js?')},"./node_modules/core-js/internals/hidden-keys.js":module=>{eval("module.exports = {};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/hidden-keys.js?")},"./node_modules/core-js/internals/ie8-dom-define.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement(\'div\'), \'a\', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/ie8-dom-define.js?')},"./node_modules/core-js/internals/indexed-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : $Object(it);\n} : $Object;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/indexed-object.js?")},"./node_modules/core-js/internals/inherit-if-required.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven\'t completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/inherit-if-required.js?')},"./node_modules/core-js/internals/inspect-source.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can\'t use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/inspect-source.js?')},"./node_modules/core-js/internals/internal-state.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar OBJECT_ALREADY_INITIALIZED = \'Object already initialized\';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError(\'Incompatible receiver, \' + TYPE + \' required\');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set = function (it, metadata) {\n    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey(\'state\');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/internal-state.js?')},"./node_modules/core-js/internals/is-array.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) == 'Array';\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/is-array.js?")},"./node_modules/core-js/internals/is-callable.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var $documentAll = __webpack_require__(/*! ../internals/document-all */ \"./node_modules/core-js/internals/document-all.js\");\n\nvar documentAll = $documentAll.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = $documentAll.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/is-callable.js?")},"./node_modules/core-js/internals/is-forced.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/is-forced.js?")},"./node_modules/core-js/internals/is-null-or-undefined.js":module=>{eval("// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nmodule.exports = function (it) {\n  return it === null || it === undefined;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/is-null-or-undefined.js?")},"./node_modules/core-js/internals/is-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar $documentAll = __webpack_require__(/*! ../internals/document-all */ \"./node_modules/core-js/internals/document-all.js\");\n\nvar documentAll = $documentAll.all;\n\nmodule.exports = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/is-object.js?")},"./node_modules/core-js/internals/is-pure.js":module=>{eval("module.exports = false;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/is-pure.js?")},"./node_modules/core-js/internals/is-symbol.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == \'symbol\';\n} : function (it) {\n  var $Symbol = getBuiltIn(\'Symbol\');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/is-symbol.js?')},"./node_modules/core-js/internals/length-of-array-like.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/length-of-array-like.js?')},"./node_modules/core-js/internals/make-built-in.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ \"./node_modules/core-js/internals/function-name.js\").CONFIGURABLE);\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/make-built-in.js?")},"./node_modules/core-js/internals/math-trunc.js":module=>{eval("var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/math-trunc.js?")},"./node_modules/core-js/internals/normalize-string-argument.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var toString = __webpack_require__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n\nmodule.exports = function (argument, $default) {\n  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/normalize-string-argument.js?")},"./node_modules/core-js/internals/object-define-property.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ \"./node_modules/core-js/internals/v8-prototype-define-bug.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-define-property.js?")},"./node_modules/core-js/internals/object-get-own-property-descriptor.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-get-own-property-descriptor.js?')},"./node_modules/core-js/internals/object-get-own-property-names.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-get-own-property-names.js?")},"./node_modules/core-js/internals/object-get-own-property-symbols.js":(__unused_webpack_module,exports)=>{eval("// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-get-own-property-symbols.js?")},"./node_modules/core-js/internals/object-is-prototype-of.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-is-prototype-of.js?')},"./node_modules/core-js/internals/object-keys-internal.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don\'t enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-keys-internal.js?')},"./node_modules/core-js/internals/object-property-is-enumerable.js":(__unused_webpack_module,exports)=>{"use strict";eval("\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-property-is-enumerable.js?")},"./node_modules/core-js/internals/object-set-prototype-of.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* eslint-disable no-proto -- safe */\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can\'t work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || (\'__proto__\' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, \'__proto__\').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/object-set-prototype-of.js?')},"./node_modules/core-js/internals/ordinary-to-primitive.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === \'string\' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== \'string\' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw $TypeError("Can\'t convert object to primitive value");\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/ordinary-to-primitive.js?')},"./node_modules/core-js/internals/own-keys.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn(\'Reflect\', \'ownKeys\') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/own-keys.js?')},"./node_modules/core-js/internals/require-object-coercible.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (isNullOrUndefined(it)) throw $TypeError("Can\'t call method on " + it);\n  return it;\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/require-object-coercible.js?')},"./node_modules/core-js/internals/shared-key.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\n\nvar keys = shared(\'keys\');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/shared-key.js?')},"./node_modules/core-js/internals/shared-store.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\n\nvar SHARED = \'__core-js_shared__\';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/shared-store.js?')},"./node_modules/core-js/internals/shared.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar store = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.26.1',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/shared.js?")},"./node_modules/core-js/internals/symbol-constructor-detection.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/symbol-constructor-detection.js?')},"./node_modules/core-js/internals/to-absolute-index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-absolute-index.js?')},"./node_modules/core-js/internals/to-indexed-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-indexed-object.js?')},"./node_modules/core-js/internals/to-integer-or-infinity.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-integer-or-infinity.js?')},"./node_modules/core-js/internals/to-length.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-length.js?')},"./node_modules/core-js/internals/to-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-object.js?')},"./node_modules/core-js/internals/to-primitive.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");\nvar ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol(\'toPrimitive\');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = \'default\';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw $TypeError("Can\'t convert object to primitive value");\n  }\n  if (pref === undefined) pref = \'number\';\n  return ordinaryToPrimitive(input, pref);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-primitive.js?')},"./node_modules/core-js/internals/to-property-key.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-property-key.js?")},"./node_modules/core-js/internals/to-string-tag-support.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-string-tag-support.js?")},"./node_modules/core-js/internals/to-string.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/to-string.js?")},"./node_modules/core-js/internals/try-to-string.js":module=>{eval("var $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/try-to-string.js?")},"./node_modules/core-js/internals/uid.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/uid.js?")},"./node_modules/core-js/internals/use-symbol-as-uid.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ \"./node_modules/core-js/internals/symbol-constructor-detection.js\");\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/use-symbol-as-uid.js?")},"./node_modules/core-js/internals/v8-prototype-define-bug.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, \'prototype\', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/v8-prototype-define-bug.js?')},"./node_modules/core-js/internals/weak-map-basic-detection.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/weak-map-basic-detection.js?')},"./node_modules/core-js/internals/well-known-symbol.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");\n\nvar WellKnownSymbolsStore = shared(\'wks\');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol[\'for\'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \'string\')) {\n    var description = \'Symbol.\' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/internals/well-known-symbol.js?')},"./node_modules/core-js/modules/es.array.push.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar setArrayLength = __webpack_require__(/*! ../internals/array-set-length */ "./node_modules/core-js/internals/array-set-length.js");\nvar doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nvar INCORRECT_TO_LENGTH = fails(function () {\n  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\n\n// V8 and Safari <= 15.4, FF < 23 throws InternalError\n// https://bugs.chromium.org/p/v8/issues/detail?id=12681\nvar SILENT_ON_NON_WRITABLE_LENGTH = !function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], \'length\', { writable: false }).push();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\n// `Array.prototype.push` method\n// https://tc39.es/ecma262/#sec-array.prototype.push\n$({ target: \'Array\', proto: true, arity: 1, forced: INCORRECT_TO_LENGTH || SILENT_ON_NON_WRITABLE_LENGTH }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  push: function push(item) {\n    var O = toObject(this);\n    var len = lengthOfArrayLike(O);\n    var argCount = arguments.length;\n    doesNotExceedSafeInteger(len + argCount);\n    for (var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      len++;\n    }\n    setArrayLength(O, len);\n    return len;\n  }\n});\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/modules/es.array.push.js?')},"./node_modules/core-js/modules/web.dom-exception.stack.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");\nvar inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");\nvar normalizeStringArgument = __webpack_require__(/*! ../internals/normalize-string-argument */ "./node_modules/core-js/internals/normalize-string-argument.js");\nvar DOMExceptionConstants = __webpack_require__(/*! ../internals/dom-exception-constants */ "./node_modules/core-js/internals/dom-exception-constants.js");\nvar clearErrorStack = __webpack_require__(/*! ../internals/error-stack-clear */ "./node_modules/core-js/internals/error-stack-clear.js");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\n\nvar DOM_EXCEPTION = \'DOMException\';\nvar Error = getBuiltIn(\'Error\');\nvar NativeDOMException = getBuiltIn(DOM_EXCEPTION);\n\nvar $DOMException = function DOMException() {\n  anInstance(this, DOMExceptionPrototype);\n  var argumentsLength = arguments.length;\n  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);\n  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], \'Error\');\n  var that = new NativeDOMException(message, name);\n  var error = Error(message);\n  error.name = DOM_EXCEPTION;\n  defineProperty(that, \'stack\', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));\n  inheritIfRequired(that, this, $DOMException);\n  return that;\n};\n\nvar DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;\n\nvar ERROR_HAS_STACK = \'stack\' in Error(DOM_EXCEPTION);\nvar DOM_EXCEPTION_HAS_STACK = \'stack\' in new NativeDOMException(1, 2);\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(global, DOM_EXCEPTION);\n\n// Bun ~ 0.1.1 DOMException have incorrect descriptor and we can\'t redefine it\n// https://github.com/Jarred-Sumner/bun/issues/399\nvar BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);\n\nvar FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;\n\n// `DOMException` constructor patch for `.stack` where it\'s required\n// https://webidl.spec.whatwg.org/#es-DOMException-specialness\n$({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, { // TODO: fix export logic\n  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException\n});\n\nvar PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);\nvar PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;\n\nif (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {\n  if (!IS_PURE) {\n    defineProperty(PolyfilledDOMExceptionPrototype, \'constructor\', createPropertyDescriptor(1, PolyfilledDOMException));\n  }\n\n  for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {\n    var constant = DOMExceptionConstants[key];\n    var constantName = constant.s;\n    if (!hasOwn(PolyfilledDOMException, constantName)) {\n      defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));\n    }\n  }\n}\n\n\n//# sourceURL=webpack://stay-popup/./node_modules/core-js/modules/web.dom-exception.stack.js?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];return void 0!==n||(n=__webpack_module_cache__[e]={exports:{}},__webpack_modules__[e](n,n.exports,__webpack_require__)),n.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}();var __webpack_exports__=__webpack_require__("./src/darkmode/dark.user.js")})();